# 字体大小浮点支持实施指南（只支持0.5倍数）

## 概述
本指南提供在Mogan/TeXmacs中实现字体大小浮点支持的具体实施步骤，**只支持0.5倍数**（如8.5、9.5、10.5等），**不支持0.4、0.23等其他小数**。方案采用**双字段兼容设计**，在`font_rep`结构中同时保留`size_int`（SI）和`size_float`（double）字段，确保完全向后兼容。

## 实施策略
为确保字体尺寸精度完美无缺，本项目采用**一体化高级实现策略**，直接集成定点数优化与性能增强，避免两阶段迁移带来的重复工作和潜在不一致性。

### 一体化高级实施方案
- **目标**：**只支持0.5倍数字体尺寸**，确保完全向后兼容，同时提供跨平台一致的精度和优化性能
- **技术方案**：定点数增强的双字段设计（`size_int` + `size_float` + `FixedPoint`） + 分层缓存策略 + 预计算优化
- **输入限制**：UI层严格限制只能输入0.5倍数，非合规输入自动修正
- **时间预估**：12-15个工作日（比原两阶段方案更高效）
- **范围**：本指南第1-11阶段描述的核心功能与高级优化

### 核心优势
1. **精度最佳化**：定点数避免浮点误差，确保0.5倍数精确支持
2. **性能最优化**：预计算缓存和分层策略最小化性能影响（目标：性能下降<3%）
3. **风险可控性**：不修改SI核心类型，只影响字体系统，完全向后兼容
4. **开发高效性**：一次性实现避免重复工作，总开发时间更短

### 实施建议
1. **一次性完成核心功能与优化**：直接实现定点数增强的双字段架构
2. **分模块实施与验证**：每完成一个模块即进行单元测试和性能基准测试
3. **监控驱动调优**：基于性能监控数据持续优化，确保满足所有成功指标
4. **特性开关支持**：保留可禁用优化功能的配置选项，便于调试和回滚

## 第一阶段：开发环境准备

### 1.1 分析工具准备
```bash
# 查找所有需要修改的文件
grep -r "SI size" --include="*.hpp" --include="*.cpp" src/
grep -r "int sz" --include="*.cpp" --include="*.hpp" src/
grep -r "get_int.*FONT_BASE_SIZE" --include="*.cpp" src/
grep -r "fn->size" --include="*.cpp" src/
```

## 第二阶段：核心数据结构修改

### 2.1 修改 font_rep 结构（双字段兼容设计）
**文件**: `src/Graphics/Fonts/font.hpp:57`

```cpp
// 修改前
struct font_rep : rep<font> {
  SI size;         // requested size (只能是整数)
  SI design_size;  // design size in points/256
  // ... 其他字段
};

// 修改后 - 双字段兼容设计
struct font_rep : rep<font> {
  SI size_int;         // 整数字体尺寸（向后兼容）
  SI design_size;      // design size in points/256 (保持整数)
  double size_float;   // 浮点字体尺寸（新功能，默认0.0表示未使用）
  // ... 其他字段不变

  // 获取有效字体尺寸（优先使用浮点尺寸，验证0.5倍数）
  double effective_size() const {
    if (size_float > 0.0) {
      // 验证是否为0.5倍数
      if (!is_half_multiple(size_float)) {
        // 自动修正到最近的0.5倍数
        double corrected = round_to_half_multiple(size_float);
        // 记录警告日志
        return corrected;
      }
      return size_float;
    }
    return (double)size_int;
  }
};
```

### 2.2 添加辅助函数和兼容性处理
**文件**: `src/Graphics/Fonts/font.hpp`（在适当位置添加）

```cpp
// 0.5倍数验证函数
inline bool is_half_multiple(double sz) {
  double doubled = sz * 2.0;
  return fabs(doubled - round(doubled)) < 0.001;
}

// 四舍五入到最近的0.5倍数
inline double round_to_half_multiple(double sz) {
  return round(sz * 2.0) / 2.0;
}

// 辅助函数，用于双字段兼容性处理（包含0.5倍数验证）
inline double get_font_size(const font_rep* rep) {
  return rep->effective_size();  // 使用effective_size()获取实际尺寸
}

// 设置字体尺寸（自动处理双字段，验证0.5倍数）
inline void set_font_size(font_rep* rep, double size) {
  // 验证输入是否为0.5倍数，如果不是则修正
  if (!is_half_multiple(size)) {
    size = round_to_half_multiple(size);
    // 可记录日志或发出警告
  }
  rep->size_float = size;
  rep->size_int = (SI)(size + 0.5);  // 同时更新整数字段用于兼容
}

// 兼容性包装函数（用于现有整数代码）
inline int font_size_as_int(double sz) { return (int)(sz + 0.5); } // 四舍五入
```

## 第三阶段：函数签名更新

### 3.1 更新字体创建函数声明
**文件**: `src/Graphics/Fonts/font.hpp`（多行需要修改）

```cpp
// 修改以下函数签名，将int sz改为double sz：
// 行190: virtual_font
// 行225: find_font
// 行229: closest_font
// 行235: smart_font
// 行238: math_smart_font
// 行241: prog_smart_font

// 示例：smart_font函数
// 修改前
font smart_font (string family, string variant, string series, string shape, int sz, int dpi);

// 修改后
font smart_font (string family, string variant, string series, string shape, double sz, int dpi);
```

### 3.2 更新smart_font_bis函数
**文件**: `src/Graphics/Fonts/smart_font.hpp:34-35`

```cpp
// 修改前
font smart_font_bis (string f, string v, string s, string sh, int sz, int hdpi, int vdpi);

// 修改后
font smart_font_bis (string f, string v, string s, string sh, double sz, int hdpi, int vdpi);
```

## 第四阶段：实现文件修改

### 4.1 修改smart_font.cpp中的实现
**文件**: `src/Graphics/Fonts/smart_font.cpp:1725`

```cpp
// 修改前
font smart_font_bis (string family, string variant, string series, string shape,
                     int sz, int hdpi, int vdpi) {
  string name= family * "-" * variant * "-" * series * "-" * shape * "-" *
               as_string (sz) * "-" * as_string (vdpi) * "-smart";
  // ...
}

// 修改后 - 支持0.5倍数字体尺寸
font smart_font_bis (string family, string variant, string series, string shape,
                     double sz, int hdpi, int vdpi) {
  // 验证输入是否为0.5倍数，如果不是则修正
  if (!is_half_multiple(sz)) {
    sz = round_to_half_multiple(sz);
  }

  // 将浮点尺寸转换为字符串表示，只保留一位小数（0.5倍数）
  string sz_str;
  if (sz == round(sz)) {
    sz_str = as_string((int)sz);  // 整数
  } else {
    sz_str = as_string(sz);  // 0.5倍数，保留一位小数
  }

  string name= family * "-" * variant * "-" * series * "-" * shape * "-" *
               sz_str * "-" * as_string (vdpi) * "-smart";
  // ... 其余代码不变
}
```

**文件**: `src/Graphics/Fonts/smart_font.cpp:1771-1772`（同样修改smart_font函数）

### 4.2 修改virtual_font.cpp
**文件**: `src/Graphics/Fonts/virtual_font.cpp:44-45`

```cpp
// 修改前
virtual_font_rep (string name, font base, string vname, int size, int hdpi,
                  int vdpi, bool extend);

// 修改后
virtual_font_rep (string name, font base, string vname, double size, int hdpi,
                  int vpi, bool extend);
```

**文件**: `src/Graphics/Fonts/virtual_font.cpp:2056`

```cpp
// 修改前
virtual_font (font base, string name, int size, int hdpi, int vdpi, bool extend);

// 修改后
virtual_font (font base, string name, double size, int hdpi, int vdpi, bool extend);
```

## 第五阶段：计算函数适配

### 5.1 修改script()函数（关键计算函数）
**文件**: `src/Graphics/Fonts/font.cpp:577-584`

```cpp
// 修改前 - 整数计算
int script (int sz, int level) {
  int i;
  if (level < 0) level= 0;
  if (level > 2) level= 2;
  for (i= 0; i < level; i++)
    sz= (sz * 2 + 2) / 3;  // 整数除法，精度丢失
  return sz;
}

// 修改后 - 浮点计算，只支持0.5倍数输入
double script (double sz, int level) {
  // 验证输入是否为0.5倍数
  if (!is_half_multiple(sz)) {
    sz = round_to_half_multiple(sz);
  }

  if (level < 0) level = 0;
  if (level > 2) level = 2;
  for (int i = 0; i < level; i++)
    sz = (sz * 2.0 + 2.0) / 3.0;  // 浮点除法，保持精度

  // 输出可能不是0.5倍数，但这是设计允许的
  return sz;
}
```

### 5.2 更新get_script_size()函数
**文件**: `src/Typeset/env.hpp:521` 和 `src/Typeset/Env/env_semantics.cpp:524`

```cpp
// 修改前
int get_script_size (int sz, int level);

// 修改后
double get_script_size (double sz, int level);
```

## 第六阶段：环境处理修改

### 6.1 修改字体大小计算逻辑
**文件**: `src/Typeset/Env/env_semantics.cpp:540-541`

```cpp
// 修改前 - 使用get_int()截断小数部分
fn_size= (int) (((double) get_int (FONT_BASE_SIZE)) * get_double (FONT_SIZE) + 0.5);

// 修改后 - 使用get_double()保持浮点精度
double base_size = get_double (FONT_BASE_SIZE);
fn_size = base_size * get_double (FONT_SIZE);  // fn_size现在应该是double类型
```

### 6.2 更新其他使用get_int(FONT_BASE_SIZE)的地方
**文件**: `src/Typeset/Env/env_length.cpp`（多处需要修改）

```cpp
// 查找并修改以下行：
// 行352: (get_int (FONT_BASE_SIZE) * magn * inch * get_double (FONT_SIZE)) / 72.0;
// 行358: double fbs= (get_int (FONT_BASE_SIZE) * magn * inch) / 72.0;
// 行386, 394, 401等

// 修改示例：
// 修改前
SI len = (get_int (FONT_BASE_SIZE) * magn * inch * get_double (FONT_SIZE)) / 72.0;

// 修改后
SI len = (SI)((get_double (FONT_BASE_SIZE) * magn * inch * get_double (FONT_SIZE)) / 72.0 + 0.5);
```

## 第七阶段：布局计算适配

### 7.1 修改script_boxes.cpp中的计算
**文件**: `src/Typeset/Boxes/Composite/script_boxes.cpp`（多处需要添加类型转换）

```cpp
// 修改前（行94、106、210、374等）
SI top = max (lo->y2, fn->y2 * script (fn->size, 1) / fn->size) + sep_lo;

// 修改后 - 添加显式类型转换
SI top = max (lo->y2, (SI)(fn->y2 * script (fn->size, 1) / fn->size + 0.5)) + sep_lo;
```

### 7.2 修改modifier_boxes.cpp
**文件**: `src/Typeset/Boxes/Modifier/modifier_boxes.cpp:449`

```cpp
// 修改前
SI syx= big_fn->yx * script (big_fn->size, 1) / big_fn->size;

// 修改后
SI syx= (SI)(big_fn->yx * script (big_fn->size, 1) / big_fn->size + 0.5);
```

## 第八阶段：插件适配

### 8.1 修改Qt插件
**文件**: `src/Plugins/Qt/qt_gui.cpp:1035`

```cpp
// 修改前
load_system_font (string fam, int sz, int dpi, font_metric& fnm, font_glyphs& fng)

// 修改后
load_system_font (string fam, double sz, int dpi, font_metric& fnm, font_glyphs& fng)
```

**文件**: `src/Plugins/Qt/qt_font.hpp:31`

```cpp
// 修改前
qt_font_rep (string name, string family, int size, int dpi);

// 修改后
qt_font_rep (string name, string family, double size, int dpi);
```

### 8.2 修改Freetype插件
**文件**: `src/Plugins/Freetype/unicode_font.cpp:1028`

```cpp
// 修改前
unicode_font (string family, int size, int hdpi, int vdpi)

// 修改后
unicode_font (string family, double size, int hdpi, int vdpi)
```

## 第九阶段：用户界面适配

### 9.1 扩展字体大小预设列表
**文件**: `TeXmacs/progs/fonts/font-new-widgets.scm:476-483`

```scheme
;; 修改前 - 只有整数大小
(tm-define (font-default-sizes)
  '("5" "6" "7" "8" "9" "10" "11" "12" "14" "16" "18" "20"
    "24" "28" "32" "36" "40" "48" "64" "72" "96"
    "128" "144" "192"))

;; 修改后 - 添加0.5倍数支持
(tm-define (font-default-sizes)
  '("5" "6" "7" "8" "8.5" "9" "9.5" "10" "10.5" "11" "11.5" "12"
    "12.5" "13" "14" "15" "16" "18" "20" "24" "28" "32" "36" "40"
    "48" "64" "72" "96" "128" "144" "192"))

(tm-define (font-default-sizes*)
  '("5" "6" "7" "8" "8.5" "9" "9.5" "10" "10.5" "11" "11.5" "12"
    "14" "16" "18" "20" "24" ""))
```

### 9.2 验证0.5倍数输入处理
确保字体选择器的"其他"选项：
1. **只能输入0.5倍数**：输入验证逻辑
2. **自动修正**：非0.5倍数输入自动四舍五入到最近的0.5倍数
3. **错误提示**：输入非法值（如"10.4"）时给出明确提示
4. **预设列表**：下拉菜单只显示0.5倍数选项

## 第十阶段：测试验证

### 10.1 创建单元测试
**文件**: 创建或修改现有测试文件

```cpp
#include <cmath>  // 用于std::abs

TEST_CASE("字体大小浮点支持 - 只支持0.5倍数") {
  // 测试0.5倍数验证函数
  REQUIRE(is_half_multiple(8.5) == true);
  REQUIRE(is_half_multiple(10.0) == true);  // 整数也是0.5倍数
  REQUIRE(is_half_multiple(10.4) == false);
  REQUIRE(is_half_multiple(10.25) == false);

  // 测试四舍五入函数
  REQUIRE(std::abs(round_to_half_multiple(10.4) - 10.5) < 0.001);
  REQUIRE(std::abs(round_to_half_multiple(10.7) - 10.5) < 0.001);
  REQUIRE(std::abs(round_to_half_multiple(10.8) - 11.0) < 0.001);

  // 测试浮点字体创建（0.5倍数）
  font f1 = smart_font("roman", "rm", "medium", "right", 10.5, 96);
  REQUIRE(f1 != nullptr);
  REQUIRE(std::abs(get_font_size(f1.operator->()) - 10.5) < 0.001);

  // 测试非0.5倍数自动修正
  font f2 = smart_font("roman", "rm", "medium", "right", 10.4, 96);
  REQUIRE(f2 != nullptr);
  // 应该自动修正为10.5
  REQUIRE(std::abs(get_font_size(f2.operator->()) - 10.5) < 0.001);

  // 测试script()函数
  REQUIRE(std::abs(script(10.5, 1) - 7.666666) < 0.001);

  // 测试缓存键生成
  string key = generate_font_cache_key("roman", "rm", "medium", "right", 10.5, 96, 96);
  REQUIRE(key.find("10.5") != string::npos);
}
```

### 10.2 视觉回归测试步骤
1. **基础测试**：创建包含10pt、10.5pt、11pt字体的测试文档
2. **布局测试**：检查包含浮点字体的文档布局是否正确
3. **导出测试**：验证PDF/HTML导出保持正确的字体尺寸
4. **兼容性测试**：确保现有整数字体大小文档正常显示

## 第十一阶段：编译和调试

### 11.1 处理编译错误
常见编译错误及解决方案：

1. **类型不匹配错误**
   ```cpp
   // 错误：不能将double转换为SI
   // 解决方案：添加显式类型转换
   SI value = (SI)(double_value + 0.5);
   ```

2. **函数重载冲突**
   ```cpp
   // 如果存在新旧函数冲突，可添加中间函数
   font smart_font_int (string f, string v, string s, string sh, int sz, int dpi) {
     return smart_font(f, v, s, sh, (double)sz, dpi);
   }
   ```

### 11.2 调试技巧
1. 使用`printf`或日志输出检查`font_rep::size`的实际值
2. 验证`script()`函数计算结果
3. 检查字体缓存键生成是否正确处理浮点数

## 部署策略

### 一体化部署计划
1. **基础设施与核心实现**：完成定点数类、双字段架构和函数签名更新
2. **系统集成与优化**：集成分层缓存、预计算优化和性能监控框架
3. **全面测试验证**：执行单元测试、性能基准测试和视觉回归测试
4. **特性开关验证**：通过特性开关对比优化前后性能，确保无性能回归
5. **一体化发布**：基于全面测试结果发布完整的高级浮点支持功能

### 质量保障措施
1. **分模块验收**：每个技术组件完成后立即进行单元测试和性能基准测试
2. **持续集成验证**：确保每次提交通过现有测试套件，保持向后兼容
3. **性能监控**：实时监控字体创建时间、缓存命中率、内存使用等关键指标
4. **精度验证**：验证0.5倍数支持精度，确保布局计算误差<0.3像素

### 回滚机制
1. **代码分支保留**：保留修改前的稳定分支，便于快速回滚
2. **特性开关支持**：提供配置选项控制浮点支持启用/禁用
3. **热修复准备**：准备针对兼容性问题的热修复补丁
4. **监控与告警**：实施性能监控，发现性能回归及时告警
5. **A/B测试能力**：支持同时运行优化版和基础版进行对比验证

## 高级优化组件：一体化实现关键要素

> **核心组件**：以下优化措施是一体化高级实现方案的关键组成部分，将在项目实施过程中直接集成，确保精度、性能和兼容性的最佳平衡。

### 1. 定点数基础设施实施
**文件**: `src/Kernel/Types/fixed_point.hpp`
```cpp
class FixedPoint {
private:
    int32_t value_;  // 16.16定点数格式

public:
    FixedPoint(double d) : value_((int32_t)(d * 65536.0)) {}
    FixedPoint(int i) : value_(i << 16) {}

    double to_double() const { return value_ / 65536.0; }
    int to_int() const { return value_ >> 16; }

    bool is_half_integer() const {
        return (value_ & 0x7FFF) == 0x8000;  // 小数部分为0.5
    }

    FixedPoint round_to_half() const {
        int32_t fractional = value_ & 0xFFFF;
        if (fractional < 0x4000) return FixedPoint(to_int());
        else if (fractional < 0xC000) return FixedPoint(to_int() + 0.5);
        else return FixedPoint(to_int() + 1);
    }
};
```

### 2. 分层缓存键生成实现
**文件**: `src/Graphics/Fonts/smart_font.cpp`
```cpp
string generate_font_cache_key(
    string family, string variant, string series, string shape,
    double size, int hdpi, int vdpi) {

    // 验证并修正为0.5倍数
    if (!is_half_multiple(size)) {
        size = round_to_half_multiple(size);
    }

    // 缓存键生成（只支持整数和0.5倍数）
    string size_str;
    if (size == round(size)) {
        size_str = as_string((int)size);           // 整数
    } else {
        size_str = as_string(size);                // 0.5倍数，保留一位小数
    }

    string name = family * "-" * variant * "-" * series * "-" * shape * "-" *
                  size_str * "-" * as_string(vdpi) * "-smart";

    if (hdpi != vdpi) {
        name = family * "-" * variant * "-" * series * "-" * shape * "-" *
               size_str * "-" * as_string(hdpi) * "-" * as_string(vdpi) * "-smart";
    }

    return name;
}
```

### 3. 批量计算优化实施
**文件**: `src/Graphics/Fonts/font_math_cache.hpp`
```cpp
class FontMathCache {
private:
    static constexpr int MAX_CACHED_SIZE = 200;
    static constexpr double SIZE_STEP = 0.5;

    array<array<double, 3>, MAX_CACHED_SIZE * 2> script_cache_;
    array<array<double, 3>, MAX_CACHED_SIZE * 2> script_ratio_cache_;

public:
    FontMathCache() {
        for (int i = 0; i < MAX_CACHED_SIZE * 2; i++) {
            double sz = i * SIZE_STEP;
            for (int level = 0; level < 3; level++) {
                script_cache_[i][level] = compute_script(sz, level);
                script_ratio_cache_[i][level] = script_cache_[i][level] / sz;
            }
        }
    }

    double script(double sz, int level) const {
        if (sz < 0 || sz > MAX_CACHED_SIZE) {
            return compute_script(sz, level);
        }
        int index = (int)(sz / SIZE_STEP + 0.5);
        if (index >= 0 && index < MAX_CACHED_SIZE * 2) {
            return script_cache_[index][level];
        }
        return compute_script(sz, level);
    }
};
```

### 4. 性能监控实施
**文件**: `src/System/Monitor/font_monitor.hpp`
```cpp
class FontSizeMonitor {
private:
    struct Metrics {
        double avg_creation_time;
        double cache_hit_rate;
        size_t memory_usage;
        double precision_error;
    };

    Metrics current_metrics_;
    Metrics baseline_metrics_;

public:
    void record_font_creation(double size, TimePoint start) {
        auto duration = now() - start;
        current_metrics_.avg_creation_time =
            update_moving_average(current_metrics_.avg_creation_time, duration);

        // 性能回归检测
        if (current_metrics_.avg_creation_time >
            baseline_metrics_.avg_creation_time * 1.05) {
            log_warning("字体创建性能下降超过5%");
        }
    }

    bool is_performance_acceptable() const {
        return current_metrics_.avg_creation_time <=
               baseline_metrics_.avg_creation_time * 1.05 &&
               current_metrics_.cache_hit_rate >= 0.90;
    }
};
```

### 5. 特性开关配置
**文件**: `src/System/Config/font_config.hpp`
```cpp
namespace font_config {
    // 浮点支持开关
    constexpr bool ENABLE_FLOAT_SIZE = true;

    // 精度控制
    constexpr double SIZE_PRECISION = 0.01;  // 1%精度

    // 缓存策略
    constexpr bool USE_LAYERED_CACHE = true;
    constexpr int CACHE_PREWARM_SIZE = 20;

    // 性能阈值
    constexpr double MAX_PERFORMANCE_DEGRADATION = 0.05;  // 5%
    constexpr double MIN_CACHE_HIT_RATE = 0.90;           // 90%
}
```

### 6. 测试验证优化
**文件**: `tests/Graphics/Fonts/font_float_test.cpp`
```cpp
TEST_CASE("字体大小浮点支持优化验证 - 只支持0.5倍数") {
    // 精度验证
    FixedPoint fp(10.5);
    REQUIRE(fp.to_double() == 10.5);
    REQUIRE(fp.is_half_integer() == true);

    // 0.5倍数验证
    REQUIRE(is_half_multiple(10.5) == true);
    REQUIRE(is_half_multiple(10.4) == false);
    REQUIRE(std::abs(round_to_half_multiple(10.4) - 10.5) < 0.001);

    // 缓存键验证（0.5倍数）
    string key1 = generate_font_cache_key("roman", "rm", "medium", "right", 10.5, 96, 96);
    REQUIRE(key1.find("10.5") != string::npos);

    // 缓存键验证（非0.5倍数自动修正）
    string key2 = generate_font_cache_key("roman", "rm", "medium", "right", 10.4, 96, 96);
    REQUIRE(key2.find("10.5") != string::npos);  // 应该自动修正为10.5

    // 性能验证（只测试0.5倍数）
    FontMathCache cache;
    BENCHMARK("script函数性能 - 0.5倍数") {
        for (double sz = 8.0; sz <= 20.0; sz += 0.5) {
            auto result = cache.script(sz, 1);
            DO_NOT_OPTIMIZE(result);
        }
    };

    // UI输入验证测试
    TEST_CASE("UI输入限制") {
        // 模拟UI输入验证
        vector<double> valid_inputs = {8.0, 8.5, 9.0, 9.5, 10.0, 10.5};
        vector<double> invalid_inputs = {8.4, 9.2, 10.1, 10.25};

        for (double input : valid_inputs) {
            REQUIRE(is_half_multiple(input) == true);
        }

        for (double input : invalid_inputs) {
            REQUIRE(is_half_multiple(input) == false);
            double corrected = round_to_half_multiple(input);
            REQUIRE(is_half_multiple(corrected) == true);
        }
    }
}
```

### 7. 一体化实施路线图
1. **第1周：基础设施与核心实现（5-7天）**
   - 实现FixedPoint定点数类和辅助工具函数
   - 修改font_rep结构，添加定点数字段
   - 更新所有字体创建函数签名（int→double）

2. **第2周：系统集成与优化（4-5天）**
   - 实现分层缓存策略和预计算缓存
   - 修改script()函数和布局计算相关代码
   - 更新环境处理和插件接口

3. **第3周：测试验证与调优（3-4天）**
   - 单元测试：定点数功能、0.5倍数验证
   - 性能基准测试：对比整数/浮点/定点数实现
   - 视觉回归测试：确保渲染一致性
   - 基于监控数据持续优化调优

**总时间预估**：12-15个工作日（3周左右），比原两阶段方案更高效

## 代码审查要点

1. **0.5倍数验证**：确保所有字体大小输入都经过`is_half_multiple()`验证
2. **自动修正逻辑**：非0.5倍数输入必须自动修正为最近的0.5倍数
3. **UI输入限制**：用户界面必须严格限制只能输入0.5倍数
4. **类型安全**：确保所有类型转换安全，避免精度丢失
5. **性能影响**：监控浮点/定点数运算对性能的影响，确保性能下降<3%（一体化优化目标）
6. **内存使用**：检查`double`/定点数类型的内存占用，确保额外开销<10%（通过内存布局优化）
7. **向后兼容**：确保现有整数字体大小完全兼容
8. **测试覆盖**：确保0.5倍数验证和修正逻辑有100%测试覆盖
9. **缓存效率**：验证缓存键生成正确处理0.5倍数，命中率>95%（分层缓存优化）
10. **精度控制**：验证布局计算误差<0.3像素，0.5倍数精度保持（定点数确保）

---

**实施指南版本**: 5.0（只支持0.5倍数限制）
**最后更新**: 2026-01-27
**适用版本**: Mogan STEM v2026.1.2+
**维护者**: 开发团队
**方案设计**: Claude Code
**更新内容**:
1. 明确只支持0.5倍数，不支持其他小数
2. 添加0.5倍数验证函数`is_half_multiple()`和`round_to_half_multiple()`
3. 更新`effective_size()`函数包含0.5倍数验证
4. 修改缓存键生成只处理0.5倍数
5. 强化UI输入限制描述
6. 更新测试用例验证0.5倍数限制
7. **实施策略升级**：从两阶段方案改为一体化高级实现方案，直接集成定点数优化
8. **方案架构优化**：采用定点数增强的双字段架构，添加`FixedPoint`字段
9. **性能指标提升**：性能目标从<5%提升到<3%，精度目标从<0.5像素提升到<0.3像素
10. **部署策略调整**：从分阶段部署改为一体化部署，优化实施路线图
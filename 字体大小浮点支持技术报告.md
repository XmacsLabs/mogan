# 字体大小浮点支持技术报告

## 目标
在现有整数字体大小支持的基础上，扩展支持**只支持0.5倍数的非整数字体大小**（如8.5、9.5、10.5、11.5等），**不支持0.4、0.23等其他小数**，同时保持与现有整数设置的完全兼容。

## 核心修改原则
1. **双字段兼容方案**：采用`size_int`（SI）和`size_float`（double）双字段设计，确保向后兼容
2. **函数接口统一**：所有字体创建函数的`int sz`参数改为`double sz`，提供整数值自动转换
3. **计算函数适配**：`script()`等计算函数改为浮点计算，**只支持0.5倍数精度**
4. **UI限制**：用户界面**必须限制输入为0.5倍数**，不支持其他小数（如0.4、0.23等）
5. **精度验证**：所有输入值必须验证是否为0.5倍数，否则四舍五入到最近的0.5倍数
6. **渐进式迁移**：优先保障现有整数功能，逐步扩展0.5倍数支持

## 完整修改清单（涉及文件和行数）

### 1. 核心数据结构修改（双字段兼容方案）

| 文件路径 | 行号 | 修改前 | 修改后 |
|---------|------|--------|--------|
| `src/Graphics/Fonts/font.hpp` | 57 | `SI size; // requested size` | `SI size_int; // 整数字体尺寸（向后兼容）` |
| `src/Graphics/Fonts/font.hpp` | 58 | `SI design_size; // design size in points/256` | `SI design_size; // 保持不变` |
| `src/Graphics/Fonts/font.hpp` | 59 | （新增字段） | `double size_float; // 浮点字体尺寸（新功能，默认0.0表示未使用）` |

### 2. 字体创建函数签名修改

| 文件路径 | 行号 | 函数签名 | 修改前 | 修改后 |
|---------|------|----------|--------|--------|
| `src/Graphics/Fonts/font.hpp` | 190 | `virtual_font` | `int sz` | `double sz` |
| `src/Graphics/Fonts/font.hpp` | 225 | `find_font` | `int sz` | `double sz` |
| `src/Graphics/Fonts/font.hpp` | 229 | `closest_font` | `int sz` | `double sz` |
| `src/Graphics/Fonts/font.hpp` | 235 | `smart_font` | `int sz` | `double sz` |
| `src/Graphics/Fonts/font.hpp` | 238 | `math_smart_font` | `int sz` | `double sz` |
| `src/Graphics/Fonts/font.hpp` | 241 | `prog_smart_font` | `int sz` | `double sz` |
| `src/Graphics/Fonts/smart_font.hpp` | 34-35 | `smart_font_bis` | `int sz` | `double sz` |
| `src/Graphics/Fonts/smart_font.cpp` | 1725 | `smart_font_bis`实现 | `int sz` | `double sz` |
| `src/Graphics/Fonts/smart_font.cpp` | 1771-1772 | `smart_font`实现 | `int sz` | `double sz` |
| `src/Graphics/Fonts/smart_font.cpp` | 1791-1792 | `math_smart_font`实现 | `int sz` | `double sz` |
| `src/Graphics/Fonts/smart_font.cpp` | 1806-1807 | `prog_smart_font`实现 | `int sz` | `double sz` |
| `src/Graphics/Fonts/font_translate.cpp` | 293 | `closest_font`实现 | `int sz` | `double sz` |
| `src/Plugins/Qt/qt_gui.cpp` | 1035 | `load_system_font` | `int sz` | `double sz` |

### 3. 虚字体构造函数修改

| 文件路径 | 行号 | 修改前 | 修改后 |
|---------|------|--------|--------|
| `src/Graphics/Fonts/virtual_font.cpp` | 44-45 | `int size` | `double size` |
| `src/Graphics/Fonts/virtual_font.cpp` | 2056 | `int size` | `double size` |

### 4. 计算函数修改

| 文件路径 | 行号 | 函数 | 修改前 | 修改后 |
|---------|------|------|--------|--------|
| `src/Graphics/Fonts/font.cpp` | 577-584 | `script` | `int script(int sz, int level)` | `double script(double sz, int level)` |
| `src/Typeset/env.hpp` | 521 | `get_script_size` | `int get_script_size(int sz, int level)` | `double get_script_size(double sz, int level)` |
| `src/Typeset/Env/env_semantics.cpp` | 524 | `get_script_size`实现 | `int sz`参数 | `double sz`参数 |

### 5. 环境处理修改

| 文件路径 | 行号 | 代码 | 修改前 | 修改后 |
|---------|------|------|--------|--------|
| `src/Typeset/Env/env_semantics.cpp` | 540-541 | 字体大小计算 | `get_int(FONT_BASE_SIZE)` | `get_double(FONT_BASE_SIZE)` |
| `src/Typeset/Env/env_length.cpp` | 352, 358, 386, 394, 401 | 长度计算 | `get_int(FONT_BASE_SIZE)` | `get_double(FONT_BASE_SIZE)` |
| `src/Edit/Editor/edit_main.cpp` | 364 | 环境处理 | `get_int(FONT_BASE_SIZE)` | `get_double(FONT_BASE_SIZE)` |
| `src/Edit/Interface/edit_repaint.cpp` | 363 | 重绘计算 | `get_init_int(FONT_BASE_SIZE)` | `get_init_double(FONT_BASE_SIZE)` |

### 6. 布局计算修改（需要类型转换）

| 文件路径 | 行号 | 代码 | 修改前 | 修改后 |
|---------|------|------|--------|--------|
| `src/Typeset/Boxes/Composite/script_boxes.cpp` | 94, 106, 210, 374 | `fn->size`计算 | `fn->y2 * script(fn->size, 1) / fn->size` | `fn->y2 * script(fn->size, 1) / fn->size`（添加`(SI)`转换） |
| `src/Typeset/Boxes/Modifier/modifier_boxes.cpp` | 449 | 修饰符计算 | `big_fn->yx * script(big_fn->size, 1) / big_fn->size` | `(SI)(big_fn->yx * script(big_fn->size, 1) / big_fn->size)` |
| `src/Typeset/Concat/concat_animate.cpp` | 231 | 动画计算 | `int sz = script(env->fn_size, env->index_level)` | `double sz = script(env->fn_size, env->index_level)` |

### 7. 字体缓存键生成修改

| 文件路径 | 行号 | 代码 | 修改前 | 修改后 |
|---------|------|------|--------|--------|
| `src/Graphics/Fonts/smart_font.cpp` | 1726-1727 | 字体名称生成 | `as_string(sz)` | `as_string(round_to_half_multiple(sz))`（只支持0.5倍数） |

### 8. UI预设列表更新

| 文件路径 | 行号 | 修改前 | 修改后 |
|---------|------|--------|--------|
| `TeXmacs/progs/fonts/font-new-widgets.scm` | 476-483 | 整数字符串列表 | 添加"8.5", "9.5", "10.5", "11.5", "12.5"等0.5倍数 |

### 9. 其他相关修改

| 文件路径 | 行号 | 修改说明 |
|---------|------|----------|
| `src/Plugins/Freetype/unicode_font.cpp` | 1028 | `int size`改为`double size` |
| `src/Plugins/Freetype/tt_face.hpp` | 36 | `int size`改为`double size` |
| `src/Plugins/Qt/qt_font.hpp` | 31 | `int size`改为`double size` |
| `src/Plugins/Metafont/load_tex.cpp` | 相关行 | `int size`改为`double size` |
| `src/Graphics/Fonts/find_font.cpp` | 相关行 | `int size`改为`double size` |

## 总文件数统计
**共计约25-30个文件需要修改**，主要集中在：
- `src/Graphics/Fonts/`目录：10-12个文件
- `src/Typeset/`目录：6-8个文件
- `src/Plugins/`目录：5-7个文件
- `TeXmacs/`目录：1个文件

## 实施步骤

### 第一阶段：核心数据结构修改（1-2天）
1. 创建开发分支：`git checkout -b yuki/font_double_size`（根据开发规范）
2. 修改`font.hpp`中的`font_rep`结构，采用双字段设计（`size_int`和`size_float`）
3. 更新所有函数签名声明（`int sz`改为`double sz`）
4. 添加辅助转换函数，修复编译错误

### 第二阶段：实现文件修改（2-3天）
1. 修改`smart_font.cpp`、`virtual_font.cpp`等实现文件
2. 更新字体缓存键生成逻辑
3. 修改计算函数

### 第三阶段：环境处理修改（1-2天）
1. 更新`env_semantics.cpp`、`env_length.cpp`等环境处理文件
2. 修改布局计算中的类型转换

### 第四阶段：插件适配（1-2天）
1. 更新Qt、Freetype、Metafont等插件
2. 确保第三方依赖兼容

### 第五阶段：测试验证（1-2天）
1. 单元测试：浮点字体创建和计算
2. 视觉测试：对比10pt、10.5pt、11pt渲染效果
3. 集成测试：完整文档渲染

### 第六阶段：UI适配（0.5-1天）
1. 更新预设列表
2. 验证浮点输入处理

## 技术要点

### 精度处理（只支持0.5倍数）
- **输入验证**：所有字体大小输入必须验证是否为0.5倍数
  ```cpp
  bool is_half_multiple(double sz) {
      double doubled = sz * 2.0;
      return fabs(doubled - round(doubled)) < 0.001;
  }

  double round_to_half_multiple(double sz) {
      return round(sz * 2.0) / 2.0;
  }
  ```
- **缓存键生成**：字体缓存键只保留一位小数，且必须是0.5倍数
- **UI限制**：用户界面只能选择或输入0.5倍数，其他小数自动修正
- **布局计算**：关键布局计算四舍五入到整数像素（`SI`类型），但保持0.5倍数精度

### 性能指标量化

#### 测试条件
- **测试环境**：标准开发机器（8核CPU，16GB RAM）
- **测试数据集**：常用字体大小范围（8.0-20.0，步长0.5）
- **测试方法**：对比整数实现与0.5倍数实现的性能差异

#### 具体测量指标
1. **字体创建时间**：测量1000次字体创建的平均时间
   - 基准：整数实现平均时间
   - 目标：0.5倍数实现增加<5%

2. **内存布局影响**：
   - `font_rep`结构体大小：`int`（4字节）vs `double`（8字节）
   - 额外内存开销：<15%（双字段设计）
   - 缓存局部性：重新组织高频访问字段

3. **缓存效率**：
   - 缓存键长度：增加约2-3字符（"10" → "10.5"）
   - 查找效率：哈希表查找时间不变
   - 命中率：>90%（预生成常用0.5倍数缓存键）

### 兼容性保证
- **整数兼容**：现有整数设置完全兼容（10 → 10.0）
- **文档兼容**：保存/重新打开保持浮点值
- **导出兼容**：PDF/HTML导出保持正确尺寸

## 风险评估与缓解

### 主要风险
1. **类型转换错误**：`SI`转`double`可能遗漏某些转换点
2. **计算精度**：浮点计算可能引入微小误差
3. **第三方依赖**：某些插件可能依赖旧的函数签名

### 缓解措施
1. **逐步修改**：从核心结构开始，逐步向外修改
2. **编译测试**：每修改一处即编译测试
3. **兼容层**：必要时添加临时兼容包装函数（如重载函数）

## 验证方法细化

### 自动化测试覆盖率指标
1. **单元测试覆盖率**：>90%的核心函数
   - `is_half_multiple()`函数：100%覆盖
   - `round_to_half_multiple()`函数：100%覆盖
   - `effective_size()`函数：边界条件全覆盖

2. **集成测试场景**：
   - 0.5倍数输入验证（8.5、9.5、10.5等）
   - 非0.5倍数自动修正（8.4 → 8.5，8.7 → 9.0）
   - 整数兼容性测试（10 → 10.0）

### 视觉回归测试的像素级差异阈值
1. **渲染精度验证**：
   - 测试条件：100%缩放，96 DPI屏幕
   - 允许误差：<0.5像素（布局计算）
   - 字体尺寸误差：<1%（10.5pt实际渲染10.4-10.6pt）

2. **像素级对比测试**：
   - 测试方法：截图对比，计算像素差异
   - 差异阈值：<0.1%像素差异（1000x1000图像中<1000像素差异）
   - 重点区域：文本基线对齐、行间距、字符间距

3. **导出格式验证**：
   - PDF导出：字体尺寸保持0.5倍数精度
   - HTML导出：CSS `font-size`属性正确设置（如`10.5pt`）
   - 跨平台一致性：Windows/Linux/macOS渲染差异<1像素

## 实施方案：一体化高级实现

### 设计理念
由于字体尺寸精度至关重要，本项目采用**一体化高级实现方案**，直接追求最完美的实现，避免两阶段迁移带来的重复工作和潜在不一致性。方案在双字段兼容架构基础上直接集成定点数优化，确保精度、性能和兼容性的最佳平衡。

### 技术方案：定点数增强的双字段架构
- **核心架构**：双字段兼容设计 + 定点数精度控制
- **目标**：支持0.5倍数字体尺寸，确保完全向后兼容，同时提供跨平台一致的精度
- **时间预估**：12-15个工作日（比原两阶段总和更高效）
- **范围**：必需的核心功能 + 高级精度优化

### 一体化高级实现方案

#### 1. 核心数据结构：定点数增强的双字段架构
```cpp
struct font_rep : rep<font> {
    SI size_int;           // 整数尺寸（向后兼容）
    SI design_size;        // 保持整数
    double size_float;     // 浮点尺寸（主要存储）
    FixedPoint size_fixed; // 定点数缓存（优化用）

    // 获取有效字体尺寸：优先使用定点数，其次浮点数，最后整数
    double effective_size() const {
        if (size_fixed.is_valid()) {
            return size_fixed.to_double();
        }
        if (size_float > 0.0) {
            // 0.5倍数验证和修正
            if (!is_half_multiple(size_float)) {
                return round_to_half_multiple(size_float);
            }
            return size_float;
        }
        return (double)size_int;
    }

    // 设置字体尺寸（自动处理0.5倍数验证和定点数转换）
    void set_size(double size) {
        // 验证并修正为0.5倍数
        if (!is_half_multiple(size)) {
            size = round_to_half_multiple(size);
        }
        size_float = size;
        size_int = (SI)(size + 0.5);  // 更新整数字段用于兼容
        size_fixed = FixedPoint(size); // 转换为定点数用于精确计算
    }
};
```

#### 2. 关键技术组件
**定点数基础设施**：
- 实现16.16定点数格式（FixedPoint类），避免浮点误差
- 支持精确的0.5倍数检测：`is_half_integer()`方法
- 提供与double的透明转换，确保跨平台一致性

**分层缓存策略**：
- **缓存键生成**：只支持0.5倍数，整数用"10"，0.5倍数用"10.5"
- **缓存预热**：预生成常用尺寸（8.0-20.0，步长0.5）的字体对象
- **键验证函数**：`generate_cache_key_for_half_multiple()`确保输入合规

**script函数优化**：
```cpp
double script(double sz, int level) {
    // 0.5倍数验证
    if (!is_half_multiple(sz)) sz = round_to_half_multiple(sz);

    // 使用预计算缓存加速（8.0-100.0，步长0.5）
    static FontMathCache cache;
    if (sz >= 8.0 && sz <= 100.0)
        return cache.script(sz, level);

    // 回退到浮点计算
    for (int i = 0; i < level; i++)
        sz = (sz * 2.0 + 2.0) / 3.0;
    return sz;
}
```

**性能监控框架**：
- 实施特性开关：可对比定点数vs浮点性能
- 实时监控字体创建时间、缓存命中率、内存使用
- 性能回归检测：超过5%性能下降自动告警

#### 3. 实施步骤与时间预估
**第一阶段：基础设施与核心实现（5-7天）**
1. 实现FixedPoint定点数类和相关工具函数
2. 修改font_rep结构，添加定点数字段
3. 更新所有字体创建函数签名（int→double）

**第二阶段：系统集成与优化（4-5天）**
1. 实现分层缓存策略和预计算缓存
2. 修改script()函数和布局计算相关代码
3. 更新环境处理和插件接口

**第三阶段：测试验证与调优（3-4天）**
1. 单元测试：定点数功能、0.5倍数验证
2. 性能基准测试：对比整数/浮点/定点数实现
3. 视觉回归测试：确保渲染一致性

**总时间预估**：12-15个工作日（比原两阶段方案更高效）

#### 4. 关键成功指标
1. **兼容性**：100%通过现有测试套件，现有整数字体大小完全兼容
2. **功能正确性**：0.5倍数字体大小正确创建和渲染，非0.5倍数自动修正
3. **精度控制**：布局计算误差<0.3像素，0.5倍数验证覆盖率100%
4. **性能基准**：字体创建时间增加<3%（优于原目标<5%）
5. **缓存效率**：缓存命中率>95%，预计算缓存加速效果显著
6. **内存影响**：额外内存开销<10%（通过内存布局优化）
7. **跨平台一致性**：定点数确保Windows/Linux/macOS渲染差异<0.5像素

#### 5. 风险评估与缓解
| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| **定点数运算性能** | 可能比整数慢 | 预计算热点路径，使用缓存优化 |
| **系统集成复杂度** | 需要修改多处代码 | 分步实施，每步编译验证 |
| **插件兼容性** | 第三方插件依赖int参数 | 提供兼容层，内部自动转换 |
| **精度误差累积** | 多次计算可能积累误差 | 关键路径使用定点数，减少转换次数 |

### 实施建议
采用**一体化高级实施方案**，直接追求最完美的实现：

1. **一次性完成核心功能与优化**：避免两阶段迁移的重复工作和潜在不一致性
2. **重点保障精度与性能**：通过定点数确保精度，通过预计算缓存保障性能
3. **渐进式验证策略**：每完成一个模块即进行单元测试和性能基准测试
4. **特性开关支持**：保留可禁用优化功能的配置选项，便于调试和回滚
5. **监控驱动优化**：基于性能监控数据持续调优，确保满足所有成功指标

**核心优势**：
- **精度最佳**：定点数避免浮点误差，确保0.5倍数精确支持
- **性能优化**：预计算缓存和分层策略最小化性能影响
- **风险可控**：不修改SI核心类型，只影响字体系统，兼容性有保障
- **效率更高**：一次性实现避免重复工作，总开发时间更短

---

**报告编写**: Claude Code
**分析日期**: 2026-01-27
**代码库版本**: Mogan STEM v2026.1.2
**分析范围**: 核心字体渲染系统与一体化高级实施策略
**更新内容**: 从两阶段实施策略升级为一体化高级实现方案，采用定点数增强的双字段架构，直接集成精度优化与性能增强，更新时间预估和成功指标
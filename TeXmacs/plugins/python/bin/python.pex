#!/usr/bin/env python
###############################################################################
#
# MODULE      : tm_python.py
# DESCRIPTION : Initialize python plugin
# COPYRIGHT   : (C) 2004       Ero Carrera, ero@dkbza.org
#               (C) 2012       Adrian Soto
#               (C) 2014       Miguel de Benito Delgado, mdbenito@texmacs.org
#               (C) 2018-2020  Darcy Shen
#
# This software falls under the GNU general public license version 3 or later.
# It comes WITHOUT ANY WARRANTY WHATSOEVER. For details, see the file LICENSE
# in the root directory or <http://www.gnu.org/licenses/gpl-3.0.html>.

import ast
import os
import platform
import sys
import tempfile
from inspect import getsource, getsourcefile
try:
    import matplotlib.pyplot as plt
    from matplotlib.figure import Figure
    from matplotlib.axes import Axes
    from matplotlib.artist import Artist
    MATPLOTLIB_AVALIABLE = True
except ModuleNotFoundError:
    MATPLOTLIB_AVALIABLE = False
    flush_verbatim ("Please install matplotlib first, for example:\n")
    flush_verbatim ("    pip install matplotlib")
try:
    import pandas as pd
    from pandas import DataFrame
    PANDAS_AVALIABLE = True
except ModuleNotFoundError:
    PANDAS_AVALIABLE = False
    flush_verbatim ("Please install pandas first, for example:\n")
    flush_verbatim ("    pip install pandas")
try:
    from sympy.printing import latex
    from sympy import Basic, MatrixBase
    import sympy
    SYMPY_AVALIABLE = True
except ModuleNotFoundError:
    SYMPY_AVALIABLE = False
    flush_verbatim ("Please install sympy first, for example:\n")
    flush_verbatim ("    pip install sympy")


from tmpy.capture import CaptureStdout
from tmpy.completion import complete, parse_complete_command
from tmpy.postscript import FileOutDummy, PSOutDummy, pdf_out, ps_out
from tmpy.protocol import (
    DATA_COMMAND,
    flush_command,
    flush_file,
    flush_prompt,
    flush_ps,
    flush_scheme,
    flush_verbatim,
    flush_latex,
)

# import logging as log
# log.basicConfig(filename='/tmp/tm_python.log',level=log.INFO)


def flush_output(data):
    """Do some parsing on the output according to its type.

    刷新输出数据到前端。

    支持类型：
    - None: 空输出
    - PSOutDummy: PostScript 内容
    - FileOutDummy: 文件内容
    - matplotlib.figure.Figure: 直接保存
    - matplotlib.axes.Axes: 保存其所属的 figure
    - matplotlib.artist.Artist: 保存其所属的 figure
    - list/tuple/dict: 递归查找第一个包含 figure 的对象
    - 其他: 转为字符串

    Non printable characters in unicode strings are escaped and objects
    of type None are not printed (so that procedure calls, as opposed to
    function calls, don't produce any output).
    """

    if data is None:
        flush_verbatim("")
        return

    if isinstance(data, PSOutDummy):
        flush_ps(data.content)
    elif isinstance(data, FileOutDummy):
        if data.content is None:
            flush_verbatim("")
        else:
            flush_file(data.content)
    elif is_matplotlib_object(data):
        fig = convert_matplotlib_object_to_figure(data)
        flush_matplotlib_figure(fig)
    elif isinstance(data, DataFrame):
        if PANDAS_AVALIABLE:
            dfstr = convert_dataframe_to_scheme_str(data)
            flush_scheme(dfstr)
    elif is_sympy_object(data):
        if SYMPY_AVALIABLE:
            flush_sympy(data)
    else:
        flush_verbatim(str(data).strip())

def flush_matplotlib_figure(fig) -> None:
    """内部辅助：安全保存并关闭 figure"""
    if not MATPLOTLIB_AVALIABLE:
        flush_verbatim("<Matplotlib not available>")
        return

    tmp_path = None
    try:
        with tempfile.NamedTemporaryFile(suffix='.pdf', delete=False) as f:
            tmp_path = f.name
            fig.savefig(tmp_path, bbox_inches='tight')
            flush_file(tmp_path)
    except Exception as e:
        flush_verbatim(f"<渲染图像失败: {e}>")
    finally:
        plt.close(fig)

def is_matplotlib_object(obj):
    module = type(obj)
    if "matplotlib" in module.__module__:
        return True
    elif "mpl_toolkits" in module.__module__:
        return True
    elif isinstance(obj, (list, tuple)):
        for item in obj:
            if isinstance(item, Artist):
                return True
            elif hasattr(item, '__getitem__') and len(item) > 0:
                f = item[0]
                if isinstance(f, Artist):
                    return f.figure
    elif isinstance(obj, dict):
        if obj.get('boxes'):
            if isinstance(obj['boxes'][0], Artist):
                return True
    else:
        return False

def convert_matplotlib_object_to_figure(obj):
    if MATPLOTLIB_AVALIABLE:
        if isinstance(obj, Figure):
            return obj
        elif isinstance(obj, Axes):
            return obj.get_figure()
        elif isinstance(obj, Artist):
            return obj.figure
        elif isinstance(obj, list) and len(obj) > 0:
            return obj[0].figure
        elif isinstance(obj, dict) and len(obj) > 0:
            return obj['boxes'][0].figure
        elif isinstance(obj, tuple) and len(obj) > 0:
            for item in obj:
                if isinstance(item, Artist):
                    return item.figure
                elif hasattr(item, '__getitem__') and len(item) > 0:
                    f = item[0]
                    if isinstance(f, Artist):
                        return f.figure
                    
def convert_dataframe_to_scheme_str(obj: DataFrame):
    row_head = "(row "
    cell_head = "(cell "
    result = "(document (tabular (tformat (cwith \\\"1\\\" \\\"1\\\" \\\"1\\\" \\\"-1\\\" \\\"cell-bborder\\\" \\\"1ln\\\") (table "
    row_index = row_head + f"{cell_head}\\\"\\\" )"
    for column in obj.columns:
        row_index = row_index + f" {cell_head}\\\"{column}\\\")" #(row (cell \"\") (cell \"{column}\")
    result = result + f"{row_index})"#row_index = (row (cell \"\") (cell \"index[1]\")...(cell \"index[n]\"))
    row_str = row_head
    for row in obj.itertuples():
        row_str = row_head + f"{cell_head}\\\"{row.Index}\\\")"#(row (cell \"row.Index\")
        for column in obj.columns:
            row_str = row_str + f" {cell_head}\\\"{getattr(row, column)}\\\")" #(row (cell \"row.Index\") (cell \"row.column[1]\")...(cell \"row.column[n]\")
        result = result + f" {row_str})"
    result = result + "))))"
    return result

def is_sympy_object(obj):
    module = type(obj)
    if "sympy" in module.__module__:
        return True
    elif isinstance(obj, (list, tuple, set)) and all(isinstance(item, (Basic, MatrixBase)) for item in obj):
        return True
    elif isinstance(obj, dict) and all(isinstance(value, (Basic, MatrixBase)) for value in obj.values()):
            return True

def flush_sympy(obj):
    if SYMPY_AVALIABLE:
        if isinstance (obj, (Basic, MatrixBase)):
            flush_latex(latex(obj))
        elif (isinstance(obj, (list, tuple, set)) and all(isinstance(item, (Basic, MatrixBase)) for item in obj)):
            flush_latex(latex(obj))
        elif (isinstance(obj, dict)) and all(isinstance(value, (Basic, MatrixBase)) for value in obj.values()):
            flush_latex(latex(obj))

def as_scm_string(text):
    return '"%s"' % text.replace("\\", "\\\\").replace('"', '\\"')

def my_eval(code, p_globals):
    """Execute a script and return the value of the last expression."""

    block = ast.parse(code, mode="exec")
    if len(block.body) > 1 and isinstance(block.body[-1], ast.Expr):
        last = ast.Expression(block.body.pop().value)
        exec(compile(block, "<string>", mode="exec"), p_globals)
        return eval(compile(last, "<string>", mode="eval"), p_globals)
    else:
        return eval(code, p_globals)


__version__ = "3.0"
__author__ = "Ero Carrera, Adrian Soto, Miguel de Benito Delgado, Darcy Shen"
my_globals = {}

# We insert into the session's namespace the 'ps_out' method.
my_globals["ps_out"] = ps_out
my_globals["pdf_out"] = pdf_out

# As well as some documentation.
my_globals[
    "__doc__"
] = """A Python plugin for TeXmacs.
Provides autocompletion and embedding of PostScript data into the document,
e.g from files or from matplotlib.pyplot.
A rudimentary help window is also implemented: type the name of an object
with a question mark at the end to use it."""

text = "import builtins as __builtins__"
CaptureStdout.capture(text, my_globals, "tm_python")

sys.stdout = os.fdopen(sys.stdout.fileno(), "w")

###############################################################################
# Session start
###############################################################################
flush_verbatim(
    f"""Python { platform.python_version() } [{ sys.executable }]
Python plugin for TeXmacs.
Please see the documentation in Help -> Plugins -> Python
"""
)
flush_prompt(">>> ")

while True:
    line = input()
    if not line:
        continue
    if line[0] == DATA_COMMAND:
        sf = parse_complete_command(line[1:])
        if sf[0] == "complete":
            flush_scheme(complete(sf[1], sf[2], my_globals))
        continue
    else:
        lines = [line]
        while line != "<EOF>":
            line = input()
            if line == "":
                continue
            lines.append(line)
        text = "\n".join(lines[:-1])
        try:  # Is it an expression?
            result = my_eval(text, my_globals)
        except Exception:
            result = CaptureStdout.capture(text, my_globals, "python")
        flush_output(result)

<TMU|<tuple|1.0.3|1.2.9.2-rc1>>

<style|<tuple|tmmanual|english>>

<\body>
  <title|About the source code of <TeXmacs>>

  <\table-of-contents|toc>
    <vspace*|1fn><with|font-series|bold|math-font-series|bold|font-shape|small-caps|1.<space|2spc>General architecture of T<rsub|<space|-0.4spc><move|<resize|<with|math-level|0|E>||||0.5fn>|0fn|-0.1fn>><space|-0.4spc>X<rsub|<space|-0.4spc><move|<resize|M<space|-0.2spc>A<space|-0.4spc>CS||||0.5fn>|0fn|-0.1fn>>> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <pageref|auto-1><vspace|0.5fn>

    1.1.<space|2spc>Introduction <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-2>

    1.2.<space|2spc>Intern representation of texts <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-3>

    <with|par-left|1tab|1.2.1.<space|2spc>Text <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-4>>

    <with|par-left|1tab|1.2.2.<space|2spc>The language <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-5>>

    1.3.<space|2spc>Typesetting texts <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-6>

    1.4.<space|2spc>Making modifications in texts <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-7>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|font-shape|small-caps|2.<space|2spc>Basic data types> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <pageref|auto-8><vspace|0.5fn>

    2.1.<space|2spc>Memory allocation and data structures in TeXmacs <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-9>

    2.2.<space|2spc>Array-like structures <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-10>

    2.3.<space|2spc>Lists <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-11>

    2.4.<space|2spc>Hash tables <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-12>

    2.5.<space|2spc>Other data structures <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-13>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|font-shape|small-caps|3.<space|2spc>Converters to other data formats> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <pageref|auto-14><vspace|0.5fn>

    3.1.<space|2spc>Parsing extern data formats <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-15>

    3.2.<space|2spc>The actual converter <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-16>

    3.3.<space|2spc>Backward conversions <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-17>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|font-shape|small-caps|4.<space|2spc>The graphical user interface> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <pageref|auto-18><vspace|0.5fn>

    4.1.<space|2spc>Introduction <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-19>

    <with|par-left|1tab|4.1.1.<space|2spc>Main architecture <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-20>>

    <with|par-left|2tab|4.1.1.1.<space|2spc>A simple example <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-21>>

    <with|par-left|1tab|4.1.2.<space|2spc>Widgets and event processing <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-22>>

    <with|par-left|2tab|4.1.2.1.<space|2spc>A simple example <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-23>>

    4.2.<space|2spc>The abstract window interface <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-24>

    <with|par-left|1tab|4.2.1.<space|2spc>Displays <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-25>>

    4.3.<space|2spc>Widget principles <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-26>

    <with|par-left|1tab|4.3.1.<space|2spc>The widget class <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-27>>

    <with|par-left|2tab|4.3.1.1.<space|2spc>The widget representation class <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-28>>

    <with|par-left|2tab|4.3.1.2.<space|2spc>The widget class <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-29>>

    <with|par-left|1tab|4.3.2.<space|2spc>The event class <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-30>>

    <with|par-left|2tab|4.3.2.1.<space|2spc>The event representation class <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-31>>

    <with|par-left|2tab|4.3.2.2.<space|2spc>The event class <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-32>>

    <with|par-left|2tab|4.3.2.3.<space|2spc>Concrete event classes <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-33>>

    <with|par-left|2tab|4.3.2.4.<space|2spc>Event handlers <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-34>>

    <with|par-left|2tab|4.3.2.5.<space|2spc>Adding your own event classes <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-35>>

    <with|par-left|1tab|4.3.3.<space|2spc>The main event loop <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-36>>

    <with|par-left|1tab|4.3.4.<space|2spc>Coordinates <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-37>>

    <with|par-left|2tab|4.3.4.1.<space|2spc>Coordinates, pixels and rounding <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-38>>

    <with|par-left|2tab|4.3.4.2.<space|2spc>Local and global coordinates <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-39>>

    <with|par-left|2tab|4.3.4.3.<space|2spc>Screen coordinates <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-40>>

    <with|par-left|1tab|4.3.5.<space|2spc>Attaching and positioning widgets <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-41>>

    <with|par-left|2tab|4.3.5.1.<space|2spc>Attaching widgets <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-42>>

    <with|par-left|2tab|4.3.5.2.<space|2spc>Positioning widgets <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-43>>

    <with|par-left|2tab|4.3.5.3.<space|2spc>Repositioning widgets <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-44>>

    <with|par-left|1tab|4.3.6.<space|2spc>The keyboard <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-45>>

    <with|par-left|2tab|4.3.6.1.<space|2spc>Keyboard focus <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-46>>

    <with|par-left|2tab|4.3.6.2.<space|2spc>Keyboard events <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-47>>

    <with|par-left|1tab|4.3.7.<space|2spc>The mouse <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-48>>

    <with|par-left|2tab|4.3.7.1.<space|2spc>Mouse events <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-49>>

    <with|par-left|2tab|4.3.7.2.<space|2spc>Grabbing the mouse <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-50>>

    <with|par-left|1tab|4.3.8.<space|2spc>The screen <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-51>>

    <with|par-left|2tab|4.3.8.1.<space|2spc>Repainting rectangles <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-52>>

    <with|par-left|2tab|4.3.8.2.<space|2spc>Invalidation of rectangles <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-53>>

    <with|par-left|1tab|4.3.9.<space|2spc>The toolkit <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-54>>

    <with|par-left|2tab|4.3.9.1.<space|2spc>Other standard widget classes <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-55>>

    <with|par-left|2tab|4.3.9.2.<space|2spc>Composite widgets <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-56>>

    <with|par-left|2tab|4.3.9.3.<space|2spc>Attribute widgets <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-57>>

    <with|par-left|2tab|4.3.9.4.<space|2spc>Glue widgets <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-58>>

    <with|par-left|2tab|4.3.9.5.<space|2spc>Text widgets <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-59>>

    <with|par-left|2tab|4.3.9.6.<space|2spc>Buttons <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-60>>

    <with|par-left|2tab|4.3.9.7.<space|2spc>Menus <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-61>>

    <with|par-left|2tab|4.3.9.8.<space|2spc>Canvas widgets <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-62>>

    <with|par-left|2tab|4.3.9.9.<space|2spc>Input widgets <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-63>>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|font-shape|small-caps|5.<space|2spc>T<rsub|<space|-0.4spc><move|<resize|<with|math-level|0|E>||||0.5fn>|0fn|-0.1fn>><space|-0.4spc>X<rsub|<space|-0.4spc><move|<resize|M<space|-0.2spc>A<space|-0.4spc>CS||||0.5fn>|0fn|-0.1fn>> fonts> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <pageref|auto-64><vspace|0.5fn>

    5.1.<space|2spc>Classical conceptions of fonts <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-65>

    5.2.<space|2spc>The conception of a font in TeXmacs <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-66>

    5.3.<space|2spc>String encodings <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-67>

    5.4.<space|2spc>The abstract font class <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-68>

    5.5.<space|2spc>Implementation of concrete fonts <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-69>

    5.6.<space|2spc>Font selection <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-70>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|font-shape|small-caps|6.<space|2spc>Mathematical typesetting> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <pageref|auto-71><vspace|0.5fn>

    6.1.<space|2spc>Introduction <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-72>

    6.2.<space|2spc>The font parameters <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-77>

    6.3.<space|2spc>Some major mathematical constructs <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-78>

    <with|par-left|1tab|6.3.1.<space|2spc>Fractions <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-79>>

    <with|par-left|1tab|6.3.2.<space|2spc>Roots <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-80>>

    <with|par-left|1tab|6.3.3.<space|2spc>Negations <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-81>>

    <with|par-left|1tab|6.3.4.<space|2spc>Wide boxes <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-82>>

    6.4.<space|2spc>Subscripts and superscripts <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-83>

    6.5.<space|2spc>Big delimiters <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-84>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|font-shape|small-caps|7.<space|2spc>The boxes produced by the typesetter> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <pageref|auto-85><vspace|0.5fn>

    7.1.<space|2spc>Introduction <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-86>

    7.2.<space|2spc>The correspondence between a box and its source <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-87>

    <with|par-left|1tab|7.2.1.<space|2spc>Discussion of the problems being encountered <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-88>>

    <with|par-left|1tab|7.2.2.<space|2spc>The three kinds of paths <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-89>>

    <with|par-left|1tab|7.2.3.<space|2spc>The conversion routines <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-90>>

    7.3.<space|2spc>The cursor and selections <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-91>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|font-shape|small-caps|Index> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <pageref|auto-92><vspace|0.5fn>
  </table-of-contents>

  <chapter|General architecture of <TeXmacs>><label|sec-architecture>

  <section|Introduction>

  The <TeXmacs> program has been written in C++. You need <verbatim|g++> and the <verbatim|makefile> utility in order to compile <TeXmacs>. Currently, the source (in the <verbatim|src> directory) of the <TeXmacs> implementation has been divided into the following parts:

  <\itemize>
    <item>A set of basic and generic data structures in the <verbatim|Basic> directory.

    <item>Standard resources for <TeXmacs>, such as <TeX> fonts, languages, encodings and dictionaries, in the <verbatim|Resource> directory.

    <item>A documented graphical toolkit in the <verbatim|Window> directory (although the documentation is a bit outdated).

    <item>The extension language for <TeXmacs> in the <verbatim|Prg> directory.

    <item>The typesetting part of the editor in the directory <verbatim|src/Typeset>.

    <item>The editor in the directory <verbatim|src/Edit>.

    <item>The <TeXmacs> server in the directory <verbatim|src/Server>.
  </itemize>

  All parts use the data structures from <verbatim|Basic>. The graphical toolkit depends on <verbatim|Resource> for the <TeX> fonts. The extension language is independent from <verbatim|Resource> and <verbatim|Window>. The typesetting part depends on all other parts except from <verbatim|Prg>. The main editor and the <TeXmacs> server use all previous parts.

  The <TeXmacs> data are contained in the directory <verbatim|edit> which corresponds to the <TeXmacs> distribution without the source code. Roughly speaking, we have the following kind of data:

  <\itemize>
    <item>Font data in <verbatim|fonts> (encodings, <verbatim|.pk> files, etc.).

    <item>Language data in <verbatim|languages> (hyphenation patterns, dictionaries, etc.).

    <item>Document styles in <verbatim|style>.

    <item>Initialization and other <scheme> programs in <verbatim|progs>.
  </itemize>

  The directory <verbatim|misc> contains some miscellaneous data like the edit icon (<verbatim|misc/pixmaps/traditional/--x17/edit.xpm>).

  <section|Intern representation of texts>

  <TeXmacs> represents all texts by trees (for a fixed text, the corresponding tree is called the <em|edit tree>). The nodes of such a tree are labeled by standard <em|operators> which are listed in <verbatim|Basic/Data/tree.hpp> and <verbatim|Basic/Data/tree.cpp>. The labels of the leaves of the tree are strings, which are either invisible (such as lengths or macro definitions), or visible (the real text).

  The meaning of the text and the way it is typeset essentially depend on the current environment. The environment mainly consists of a relative hash table of type <verbatim|rel_hashmap\<less\>string,tree\<gtr\>>, i.e. a mapping from the environment variables to their tree values. The current language and the current font are examples of system environment variables; new variables can be defined by the user.

  <subsection|Text>

  All text strings in <TeXmacs> consist of sequences of either specific or universal symbols. A specific symbol is a character, different from <verbatim|'\\0'>, <verbatim|'\<less\>'> and <verbatim|'\<gtr\>'>. Its meaning may depend on the particular font which is being used. A universal symbol is a string starting with <verbatim|'\<less\>'>, followed by an arbitrary sequence of characters different from <verbatim|'\\0'>, <verbatim|'\<less\>'> and <verbatim|'\<gtr\>'>, and ending with <verbatim|'\<gtr\>'>. The meaning of universal characters does not depend on the particular font which is used, but different fonts may render them in a different way.

  <subsection|The language>

  The language of the text is capable performing a further semantic analysis of a text phrase. At least, it is capable of splitting a phrase up into <em|words> (which are smaller phrases) and inform the typesetter about the desired spaces between words and hyphenation information. In the future, additional semantics may be added into languages. For instance, spell checkers might be implemented for natural languages and parsers for mathematical formulas or programming languages.

  <section|Typesetting texts>

  Roughly speaking, the typesetter of <TeXmacs> takes a tree on input and produces a box, while accessing and modifying the typesetting environment. The <verbatim|box> class is multifunctional. Its principal method is used for displaying the box on a post-script device (either the screen or a printer). But it also contains a lot of typesetting information, such as logical and ink bounding boxes, the positions of scripts, etc.

  Another functionality of boxes is to convert between physical cursors (positions on the screen) and logical cursors (paths in the edit tree). Actually, boxes are also organized into a tree, which often simplifies the conversion. However, because of macro expansions and line and page breaking, the conversion routines may become quite intricate. Notice also that, besides a horizontal and vertical position, the physical cursor also contains an infinitesimal horizontal position. Roughly speaking, this infinitesimal coordinate is used to give certain boxes (such as color changes) an extra infinitesimal width.

  <section|Making modifications in texts>

  In <verbatim|Edit/Modify> you find different routines for modifying the edit tree. Modifications go in several steps:

  <\enumerate>
    <item>A certain input event triggers an action, such as <verbatim|make_fraction>, which intends to modify the edit tree.

    <item>All modifications which <verbatim|make_fraction> or its subroutines will make to the edit tree eventually break down to seven elementary modification routines, namely <verbatim|assign>, <verbatim|insert>, <verbatim|remove>, <verbatim|split>, <verbatim|join>, <verbatim|ins_unary> and <verbatim|rem_unary>.

    <item>Before performing the required modification, the elementary modification routine first notifies all views of the same text of the modification.

    <item>On notification, each view updates several things, such as the cursor position. It also notifies the modification to the typesetter of the text, since the typesetter maintains a list of already typeset paragraphs.

    <item>When all views have been notified of the modification, we really perform it.

    <item>Each user action like a keystroke or a mouse click is responsible for inserting <em|undo points> between sequences of elementary modifications. When undoing a modification, the editor will move to the previous undo point.
  </enumerate>

  <chapter|Basic data types><label|sec-types>

  In this chapter, we give a rough description of <TeXmacs>'s basic data types in <verbatim|Basic>. The description of the exported functions is non exhaustive and we refer to the corresponding header files for more precision.

  <section|Memory allocation and data structures in TeXmacs>

  The file <verbatim|fast_alloc.hpp> declares the <TeXmacs> memory allocation routines. These routines are very fast for small sizes, since for each such size, <TeXmacs> maintains a linked list of freed objects of that size. No garbage collection has been implemented yet.

  Modulo a few exceptions, all <TeXmacs> composite data structures are based on the modules <verbatim|concrete>, <verbatim|abstract>, <verbatim|concrete_null> and <verbatim|abstract_null>. Consequently, these data structures are pointers to representation classes, which may be abstract in the case of <verbatim|abstract> and <verbatim|abstract_null>, and which always contain a reference counter. Because of the reference counter, the C++ copy operator is very fast. Most of the implemented data structures also export a function <verbatim|copy>, which should be used if one really wants to physically duplicate an object,

  For classes constructed using <verbatim|concrete_null> or <verbatim|abstract_null>, the pointer to the representation class is allowed to be <verbatim|NULL> and we have a default constructor which initializes this pointer with <verbatim|NULL>. Instances of these classes are tested to be <verbatim|NULL> using the function <verbatim|nil>. Examples of such classes are lists, files and widgets.

  <section|Array-like structures>

  <TeXmacs> implements three “array-like” structures:

  <\itemize>
    <item><verbatim|string> is the string type, which may contain '0' characters.

    <item><verbatim|tree> is the tree type with string labels.

    <item><verbatim|array\<less\>T\<gtr\>> is the generic array type with elements of type <verbatim|T>.
  </itemize>

  Array-like structures export the following operations:

  <\itemize>
    <item><verbatim|N> computes the length of an array.

    <item><verbatim|[]> accesses an element.

    <item><verbatim|\<less\>\<less\>> is used for appending elements or arrays.
  </itemize>

  For trees <verbatim|t>, we notice that <verbatim|t-\<gtr\>label> yields the label of the tree and <verbatim|t-\<gtr\>a> the array of its children. The second argument of <verbatim|\<less\>\<less\>> for trees is either a tree or an array of trees.

  The implementation has been made such that the <verbatim|\<less\>\<less\>> operation is fast, which is useful when considering arrays as buffers. Actually, the allocated space for arrays with more than five elements (words for strings) is always a power of two, so that new elements can be appended quickly. Notice that GNU malloc also always allocates blocks, whose sizes are powers of two. Therefore, we do not waste memory for small and large arrays.

  <section|Lists>

  Generic lists are implemented by the class <verbatim|list\<less\>T\<gtr\>>. The “nil” list is created using <verbatim|list\<less\>T\<gtr\>()>, an atom using <verbatim|list\<less\>T\<gtr\>(T x)> and a general list using <verbatim|list\<less\>T\<gtr\>(T x, list\<less\>T\<gtr\> next)>. If <verbatim|l> is a list, <verbatim|l-\<gtr\>item> and <verbatim|l-\<gtr\>next> correspond to its label and its successor respectively (<verbatim|car> and <verbatim|cdr> in lisp). The functions <verbatim|nil> and <verbatim|atom> tests whether a list is nil or an atom. The function <verbatim|N> computes the length of a list.

  The type <verbatim|list\<less\>T\<gtr\>> is also denoted by <verbatim|path>, because some additional functions are defined for it. Indeed, paths are used for accessing descendants in tree like structures. For instance, we implemented the function <verbatim|tree subtree (tree t, path p)>.

  <section|Hash tables>

  The <verbatim|hashmap\<less\>T,U\<gtr\>> class implements hash tables with entries in <verbatim|T> and values in <verbatim|U>. A function <verbatim|hash> should be implemented for <verbatim|T>. Given a hash table <verbatim|H>. We set elements through\ 

  <\verbatim>
    \ \ \ \ H(x)=y;
  </verbatim>

  and access to elements through\ 

  <\verbatim>
    \ \ \ \ H[x]
  </verbatim>

  We also implemented a variant <verbatim|rel_hashmap\<less\>T,U\<gtr\>> of hash tables, which also have a list-like structure, which makes them useful for implementing recursive environments.

  <section|Other data structures>

  <\itemize>
    <item><verbatim|command> implements abstract commands.

    <item><verbatim|file> implements files.

    <item><verbatim|iterator\<less\>T\<gtr\>> implements generic iterators.

    <item><verbatim|rectangles> implements rectangles and lists of rectangles.

    <item><verbatim|space> implements stretchable spaces.

    <item><verbatim|timer> implements timers.
  </itemize>

  <chapter|Converters to other data formats><label|sec-conversions>

  Currently, we have implemented imperfect converters between <TeXmacs> and <LaTeX> and from html to <TeXmacs>. We hope that someone else will be willing to write better converters from scratch. This chapter has been included in order to give some recommendations in that direction based on our experience from the implementation of the actual conversion programs. We also recommend to take a look at the current implementations in the directory <verbatim|Convert>.

  <section|Parsing extern data formats>

  In order to write a converter from <LaTeX> html, xml, etc. to <TeXmacs>, a good first step is to write a parser for the extern data format. For html, xml, etc. this should be rather easy, but for <LaTeX>, you will probably need to be a real <LaTeX> guru (which I am not). We recommend the result of the parsing step to be a <scheme> expression (something which is regrettable not the case for our actual converters), because this language is very well adapted for the implementation of the actual converter.

  This first step should be able to process any correct file having the extern data format; possible incompatibilities should only come into play during the actual conversion. In the case of <LaTeX>, one should not expand the macros and keep all macro definitions, because <TeXmacs> will be able to take advantage out of this.

  <section|The actual converter>

  We recommend the actual converter to proceed in several steps. Often it is convenient to start with a rough, structural, conversion step, which is “polished” by a certain number of additional steps. These additional steps may take care of some very particular layout issues which can not be treated conveniently at the main step.

  Actually, the main difficulties usually come from exceptional text, like verbatim, and layout issues which are handled differently in the extern data format and <TeXmacs>. A good example of such a difference between <LaTeX> and <TeXmacs> is the way equations or lists are handled. Consider for instance the following paragraph:

  Text before.

  <\equation*>
    a<rsup|2>+b<rsup|2>=c<rsup|2>.
  </equation*>

  Text after.

  In <LaTeX>, the equation is really seen as a part of the paragraph. Indeed, there will not be any blank line between “Text before” and the equation. However, for efficiency reasons, it is better to see the paragraph as three paragraphs in <TeXmacs>, because the lines can be typeset independently. Nevertheless, the equation environment will disable the indentation of “Text after”.

  As a result of this anomaly, converted texts have to be postprocessed, so as to insert paragraph breaks at strategic places. It should be noticed that this step may be independent from the format which is actually being converted and that a similar reverse step may be implemented for backward conversions. We also notice that one needs an exhaustive list of all similar exceptional environments for this postprocessing step. Actually, a future version of <TeXmacs> might come with an additional feature, which permits the automatic detection of such environments. This is also important from a semantical point of view, because one should be able to detect that the above example logically forms only one and not three paragraphs.

  <section|Backward conversions>

  Conversions from <TeXmacs> to an extern data format are usually easier to implement, because the <TeXmacs> data format is semantically rich. However, conversions to an extern data format without a <TeX>-like macro facility give rise to the problem of macro expansion of non supported <TeXmacs> functions or environments. We plan to write a facility for this, which you will be able to use when writing a converter from <TeXmacs> to something else.

  <chapter|The graphical user interface><label|sec-gui>

  <section|Introduction>

  <subsection|Main architecture>

  The graphical toolkit used by Edit has two main components: an abstract window interface, which is very similar to X Window, and the actual toolkit. At this moment an abstract window interface for X Window has been implemented, but others might be added in the future.

  The abstract window interface consists of two main classes: <verbatim|display> and <verbatim|window>. The <verbatim|display> class is responsible for

  <\itemize>
    <item>The connection with the (X-)server.

    <item>Managing server resources such as colors and fonts.

    <item>Inter-window communication (i.e. selections and so).

    <item>Redirection of input/output (pointer and keyboard grabs).
  </itemize>

  The <verbatim|window> class is responsible for

  <\itemize>
    <item>The part of the layout of a window, which is negotiated with the window manager.

    <item>Providing a basic set of postscript-compatible graphical routines.

    <item>Implementation of some clipping and region translation routines.

    <item>Delegation of events to the widget associated to the window.
  </itemize>

  In particular, the <verbatim|window>-class inherits from the <verbatim|ps_device>-class, which is responsible for providing the basic set of postscript-compatible graphical routines. Hence, user applications will draw their graphics on a <verbatim|ps_device>, since this will both allow them to visualize them in a window or on a printer.

  The graphical toolkit built on top of the abstract window interface is widget oriented. A large number of widget classes are implemented, which all inherit from the abstract <verbatim|widget> class. Widgets may have a finite number of children and they are responsible for

  <\itemize>
    <item>Their, and their children, sizes and positioning in the window.

    <item>Reaction on events, which are either redraw requests, keyboard or pointer events or other miscellaneous events.

    <item>Other functionalities, which depend on the particular widget class.
  </itemize>

  Later a special widget-style manager will be implemented, which will be able to present widgets according to different “styles”.

  <subsubsection|A simple example>

  In order to create a window “Test” with the text “Hello world” in it, one first opens the display, then create the widget with the text and finally the window, with the widget attached to it\ 

  <\verbatim>
    \ \ \ \ display dis= open_display ();<next-line> \ \ \ widget \ wid= text_widget ("Hello world");<next-line> \ \ \ window \ win= plain_window (wid, dis, "Test");
  </verbatim>

  Technically speaking, the window creation amounts to several actions:

  <\itemize>
    <item>The widget is questioned for an appropriate size for it (actually, only minimal, default and maximal size hints are computed).

    <item>The window is created.

    <item>The widget is “attached” to the window.

    <item>The subwidgets are “positioned” at their appropriate places and they are given appropriate sizes within their parents.
  </itemize>

  The next step is to make the window visible by\ 

  <\verbatim>
    \ \ \ \ win-\<gtr\>map ();
  </verbatim>

  At this points repaint request events are generated, which are handled when starting the event loop by\ 

  <\verbatim>
    \ \ \ \ dis-\<gtr\>event_loop ();
  </verbatim>

  Eventually, the window <verbatim|win> will be destroyed using\ 

  <\verbatim>
    \ \ \ \ delete win;
  </verbatim>

  At this point, control is handled back by the event loop and we close and destroy the display by\ 

  <\verbatim>
    \ \ \ \ close_display (dis)<next-line> \ \ \ delete dis;
  </verbatim>

  The user only has to bother about destroying window and displays; widgets are automatically destroyed if they are no longer being referenced to.

  <subsection|Widgets and event processing>

  From the implementation point of view, widgets are pointers to instances of the abstract widget representation class <verbatim|widget_rep>. Moreover, the widget class supports reference counting. The <verbatim|widget_rep> class contains information about the window it is attached to and its location within this window, its size, the position of the origin of its local coordinates (<verbatim|north_west>, <verbatim|north>, etc.) and its children. The <verbatim|widget_rep> class also provides a virtual event handler <verbatim|widget_rep::handle>. This handler returns true if the event could be handled.

  The implemented widget representation classes are organized in a hierarchy, which contains both concrete and abstract classes. The abstract classes reimplement the virtual event handler <verbatim|widget_rep::handle> in such a way that if the event is recognized, then the event is dispatched to a more particular virtual event handler, possibly after some processing.

  For example, instances of the <verbatim|basic_widget_rep> class can handle the most common events, such as keyboard, mouse, repaint events and so on. If a key is pressed, then the virtual function <verbatim|basic_widget_rep::handle_keypress> is called with an argument of type <verbatim|keypress_event>. The default implementation of this virtual function does nothing.

  The user can also create his own events, which he can pass to any widget. For instance in order to invalidate a region for redrawing, one creates an invalidate event using <verbatim|emit_invalidate> and sends it to the appropriate widget using the operator <verbatim|\<less\>\<less\>>. Notice that the user is responsible for sending events to widgets which can handle them. Bad matches are only discovered at run time, in which case an error is generated by <verbatim|\<less\>\<less\>>.

  <subsubsection|A simple example>

  Suppose that we want to make a widget, which tracks keyboard events and which displays them. Such a widget must have a construction routine and keyboard and repaint handlers:\ 

  <\verbatim>
    \ \ \ \ class track_widget_rep: basic_widget_rep {<next-line> \ \ \ \ \ string last_key;<next-line> \ \ \ \ \ track_widget_rep ();<next-line> \ \ \ \ \ void handle_keypress (keypress_event ev);<next-line> \ \ \ \ \ void handle_repaint (repaint_event ev);<next-line> \ \ \ };
  </verbatim>

  The constructor is taken to be empty and places the origin at the center of the widget\ 

  <\verbatim>
    \ \ \ \ track_widget_rep::track_widget_rep (): basic_widget (center) {}
  </verbatim>

  In particular <verbatim|last_key> is initialized by the empty string. We also define the function\ 

  <\verbatim>
    \ \ \ \ void<next-line> \ \ \ track_widget () {<next-line> \ \ \ \ \ return new track_widget_rep ();<next-line> \ \ \ }
  </verbatim>

  in order to create an instance of a <verbatim|track_widget>.

  The event handler for keyboard events should just reset the string <verbatim|last_key> and invalidate the entire widget region.\ 

  <\verbatim>
    \ \ \ \ void<next-line> \ \ \ track_widget_rep::handle_keypress (keypress_event ev) {<next-line> \ \ \ \ \ last_key= ev-\<gtr\>key;<next-line> \ \ \ \ \ this \<less\>\<less\> emit_invalidate_all ();<next-line> \ \ \ }
  </verbatim>

  The event handler for repainting first determines the string to be repainted as a function of <verbatim|last_key>, computes its extents and repaints it at the center.\ 

  <\verbatim>
    \ \ \ \ void<next-line> \ \ \ track_widget_rep::handle_repaint (repaint_event ev) {<next-line> \ \ \ \ \ string s= (last_key == ""? "No key pressed": "Pressed " * last_key);<next-line><next-line> \ \ \ \ \ SI x1, y1, x2, y2;<next-line> \ \ \ \ \ win-\<gtr\>get_extents (s, x1, y1, x2, y2); // CHECK THIS<next-line><next-line> \ \ \ \ \ win-\<gtr\>set_color (black);<next-line> \ \ \ \ \ win-\<gtr\>fill (ev-\<gtr\>x1, ev-\<gtr\>y1, ev-\<gtr\>x2, ev-\<gtr\>y2);<next-line> \ \ \ \ \ win-\<gtr\>set_color (white);<next-line> \ \ \ \ \ win-\<gtr\>draw_string (s, -(x1+x2)\<gtr\>\<gtr\>1, -(y1+y2)\<gtr\>\<gtr\>1);<next-line> \ \ \ }
  </verbatim>

  \;

  <section|The abstract window interface>

  <subsection|Displays>

  <section|Widget principles>

  <subsection|The widget class>

  Widgets are pointers to instances of the abstract widget representation class <verbatim|widget_rep>. Widgets support reference counting, so that a widget is automatically destroyed if it is not used any more (except in the case of circular referencing; see below). As a general rule, the user does not have to worry about the creation and destruction of widgets.

  <subsubsection|The widget representation class>

  The definition of the <verbatim|widget_rep> class goes as follows:\ 

  <\verbatim>
    \ \ \ \ struct widget_rep: rep_struct {<next-line> \ \ \ \ \ window \ \ \ \ \ \ \ win; \ \ \ \ \ \ \ \ \ \ // underlying window<next-line> \ \ \ \ \ SI \ \ \ \ \ \ \ \ \ \ \ ox, oy; \ \ \ \ \ \ \ // origin of widget in window<next-line> \ \ \ \ \ SI \ \ \ \ \ \ \ \ \ \ \ w, h; \ \ \ \ \ \ \ \ \ // width and height of widget<next-line> \ \ \ \ \ gravity \ \ \ \ \ \ grav; \ \ \ \ \ \ \ \ \ // position of the origin in the widget<next-line> \ \ \ \ \ array\<less\>widget\<gtr\> a; \ \ \ \ \ \ \ \ \ \ \ \ // children of widget<next-line> \ \ \ \ \ array\<less\>string\<gtr\> name; \ \ \ \ \ \ \ \ \ // names for the children<next-line><next-line> \ \ \ \ \ widget_rep (array\<less\>widget\<gtr\> a, array\<less\>string\<gtr\> name, gravity grav);<next-line> \ \ \ \ \ virtual ~widget_rep ();<next-line><next-line> \ \ \ \ \ virtual operator tree () = 0;<next-line> \ \ \ \ \ virtual bool handle (event ev) = 0;<next-line><next-line> \ \ \ \ \ SI \ \ \ \ \ \ x1 (); SI y1 (); // lower left window coordinates of widget<next-line> \ \ \ \ \ SI \ \ \ \ \ \ x2 (); SI y2 (); // upper right window coordinates of widget<next-line> \ \ \ \ \ bool \ \ \ \ attached (); \ \ \ \ // tests whether (win != NULL)<next-line> \ \ \ \ \ volatile void fatal_error (string mess, string rout="", string fname="");<next-line> \ \ \ <next-line> \ \ \ \ \ friend class widget;<next-line> \ \ \ };
  </verbatim>

  \;

  The <verbatim|win> field specifies the window to which the widget is attached (<verbatim|win=NULL>, by default). The origin <verbatim|(ox,oy)> of the widget is specified with respect to the windows origin. Next come the width <verbatim|w> and the height <verbatim|h> of the widget. The gravity <verbatim|grav> determines where the origin of the widget is located (<verbatim|north_west>, <verbatim|north>, etc.). The array <verbatim|a> specifies the children of the widget. The array <verbatim|name> gives names to the children of the widget. This is useful for addressing children by comprehensible names; the names are also useful for designing menu widgets.

  The virtual type casting operator for trees is used for debugging purposes; mainly in order to print widgets. The virtual member function <verbatim|handle> processes an event which is send to the widget and returns <verbatim|TRUE> if the event could be handled and <verbatim|FALSE> if not.

  <subsubsection|The widget class>

  The definition of the <verbatim|widget> class goes as follows:\ 

  <\verbatim>
    \ \ \ \ struct widget {<next-line> \ \ \ #import null_indirect_h (widget, widget_rep)<next-line> \ \ \ \ \ inline widget (widget_rep* rep2): rep (rep2) {<next-line> \ \ \ \ \ \ \ if (rep!=NULL) rep-\<gtr\>ref_count++; }<next-line> \ \ \ \ \ inline widget operator [] (int i) { return rep-\<gtr\>a[i]; }<next-line> \ \ \ \ \ \ \ \ \ \ \ \ widget operator [] (string s);<next-line> \ \ \ \ \ inline operator tree () { return (tree) (*rep); }<next-line> \ \ \ \ \ inline bool operator == (widget w) { return rep == w.rep; }<next-line> \ \ \ \ \ inline bool operator != (widget w) { return rep != w.rep; }<next-line> \ \ \ };
  </verbatim>

  \;

  Widgets may be constructed in two ways. First, we may construct a symbolic “nil” widget by <verbatim|widget ()>. The function <verbatim|bool nil (widget)> is provided in order to test whether a widget is “nil”. Secondly, we may construct a widget from a pointer of type <verbatim|widget_rep*>.

  The reference counting mechanism ensures widgets to be destroyed when they are no longer pointed to. An important exception is when two widgets point one to each other, which fools the reference counter (for instance a scrollbar and the widget which is scrolled need to point one to each other). In order to deal with such “circular dependencies”, one works directly with <verbatim|widget_rep*> pointers if one does not want to the pointer to be taken into account in the reference counter.

  Child widgets can again be accessed to in two ways. First, we have the direct way, using its index in the array <verbatim|a>. Secondly, we can access to a child via its name. Actually, when using this method, a <verbatim|get_widget> event is generated. In the basic widget class, the default action for this event is to search in the name array for the child. However, the user may override this default action and provide another child searching method.

  <subsection|The event class>

  Events are pointers to instances of the abstract <verbatim|event_rep> class, which supports reference counting. Actually, concrete event representation classes just contain some information. Hence, events actually provide a safe and generic way to store and communicate information.

  <subsubsection|The event representation class>

  The definition of the <verbatim|event_rep> structure is as follows:\ 

  <\verbatim>
    \ \ \ \ struct event_rep: public rep_struct {<next-line> \ \ \ \ \ int \ \ \ type; \ // the event type<next-line> \ \ \ \ \ inline event_rep (int type2): rep_struct (0), type (type2) {}<next-line> \ \ \ \ \ inline virtual ~event_rep () {}<next-line> \ \ \ \ \ virtual operator tree () = 0; \ \ // for displaying events (debugging)<next-line> \ \ \ };
  </verbatim>

  \;

  The <verbatim|type> field gives the type of the event. A complete list of the event types if given in the file\ 

  <\verbatim>
    \ \ \ \ Window/Event/event_codes.hpp
  </verbatim>

  For each project which uses new event types, an analogue file should be made and the numbers of the event types should all be different. Unfortunately, there is no safe way in order to let this job be done by the compiler.

  <subsubsection|The event class>

  The <verbatim|event> structure is defined by\ 

  <\verbatim>
    \ \ \ \ struct event {<next-line> \ \ \ #import indirect_h (event, event_rep) \ \ \ \ \ \ \ \ \ \ \ <next-line> \ \ \ \ \ inline event (event_rep* rep2): rep (rep2) {<next-line> \ \ \ \ \ \ \ if (rep!=NULL) rep-\<gtr\>ref_count++; }<next-line> \ \ \ \ \ inline operator tree () { return (tree) (*rep); }<next-line> \ \ \ };<next-line> \ \ \ #import indirect_cc (event, event_rep)
  </verbatim>

  \;

  <subsubsection|Concrete event classes>

  Concrete event classes again come into two parts: the class itself and its representation class. For instance, the representation class for <verbatim|get_widget> events is defined by\ 

  <\verbatim>
    \ \ \ \ struct get_widget_event_rep: public event_rep {<next-line> \ \ \ \ \ string which; widget& w;<next-line> \ \ \ \ \ get_widget_event_rep (string which, widget& w);<next-line> \ \ \ \ \ operator tree ();<next-line> \ \ \ };
  </verbatim>

  The corresponding <verbatim|get_widget_event> class is defined by\ 

  <\verbatim>
    \ \ \ \ #import event (get_widget_event, get_widget_event_rep)
  </verbatim>

  \;

  The module <verbatim|event> with two parameters is defined by\ 

  <\verbatim>
    \ \ \ \ #module event (T, R)<next-line> \ \ \ struct T {<next-line> \ \ \ \ \ R* rep;<next-line> \ \ \ \ \ T (T& ev);<next-line> \ \ \ \ \ ~T ();<next-line> \ \ \ \ \ T (event& ev);<next-line> \ \ \ \ \ operator event ();<next-line> \ \ \ \ \ R* operator -\<gtr\> ();<next-line> \ \ \ \ \ T& operator = (T ev);<next-line> \ \ \ };<next-line> \ \ \ #endmodule // event (T, R)
  </verbatim>

  The important thing to notice is that we have converters from and to the generic <verbatim|event> class. Moreover, the generic <verbatim|event> class and the specific <verbatim|get_widget_event> class are compatible from the reference counting point of view.

  The implementation of the <verbatim|get_widget_event_rep> class is as follows:\ 

  <\verbatim>
    \ \ \ \ get_widget_event_rep::get_widget_event_rep (string ww, widget& w2):<next-line> \ \ \ \ \ event_rep (GET_WIDGET_EVENT), which (ww), w (w2) {}<next-line> \ \ \ get_widget_event_rep::operator tree () {<next-line> \ \ \ \ \ return tree ("get_widget_event", which); }<next-line> \ \ \ #import code_event (get_widget_event, get_widget_event_rep)
  </verbatim>

  The actual events are created by\ 

  <\verbatim>
    \ \ \ \ event get_widget (string which, widget& w) {<next-line> \ \ \ \ \ return new get_widget_event_rep (which, w); }
  </verbatim>

  \;

  <subsubsection|Event handlers>

  Implementations of the generic event handler <verbatim|bool widget_rep::handle(event)> usually do the following

  <\itemize>
    <item>Determine the event type.

    <item>Perform some action, depending on the event type and the widget.

    <item>Dispatch the event to a concrete or abstract specific event handler or to the generic event handler of some other widget representation class.
  </itemize>

  For instance, the event handler for composite widgets is as follows:\ 

  <\verbatim>
    \ \ \ \ bool<next-line> \ \ \ composite_widget_rep::handle (event ev) {<next-line> \ \ \ \ \ switch (ev-\<gtr\>type) {<next-line> \ \ \ \ \ case CLEAN_EVENT:<next-line> \ \ \ \ \ \ \ handle_clean (ev);<next-line> \ \ \ \ \ \ \ return TRUE;<next-line> \ \ \ \ \ case INSERT_EVENT:<next-line> \ \ \ \ \ \ \ handle_insert (ev);<next-line> \ \ \ \ \ \ \ return TRUE;<next-line> \ \ \ \ \ case REMOVE_EVENT:<next-line> \ \ \ \ \ \ \ handle_remove (ev);<next-line> \ \ \ \ \ \ \ return TRUE;<next-line> \ \ \ \ \ }<next-line> \ \ \ \ \ return basic_widget_rep::handle (ev);<next-line> \ \ \ }
  </verbatim>

  The member function <verbatim|handle_insert> is implemented as follows:\ 

  <\verbatim>
    \ \ \ \ void<next-line> \ \ \ composite_widget_rep::handle_insert (insert_event ev) {<next-line> \ \ \ \ \ a \<less\>\<less\> ev-\<gtr\>w;<next-line> \ \ \ \ \ name \<less\>\<less\> ev-\<gtr\>s;<next-line> \ \ \ }
  </verbatim>

  In particular, we can retrieve the fields <verbatim|w> and <verbatim|s> from <verbatim|insert_event_rep> from the <verbatim|insert_event> in the member function.

  <subsubsection|Adding your own event classes>

  Summarizing, in order to add your own new event classes, you have to take care of the following steps:

  <\itemize>
    <item>Add a new event type to some <verbatim|event_codes> file.

    <item>Declare and implement the event type and its representation type.

    <item>Declare and implement the event creation functions.

    <item>Reimplement the generic event handler <verbatim|bool widget_rep::handle(event)> in the abstract or concrete widget representation class, where you want to use your new event class.
  </itemize>

  <subsection|The main event loop>

  The main event loop does the following

  <\itemize>
    <item>As long as the application did not destroy all its windows, wait for a new event to occur.

    <item>If an event occurs, handle all events on the queue, by creating the appropriate events and sending them to the appropriate widgets (job of the window interface implementation).

    <item>If there are no events left, send an <verbatim|inquire_event> to each window. This is useful for complex applications, where regions of the window may be invalidated during this phase. Indeed, the event handling phase may consist of many complex actions, so that the regions to invalidate may be determined easier <with|font-shape|italic|a posteriori>.

    <item>Requests are emitted in order to repaint the regions which have been invalidated during the event processing stages.
  </itemize>

  <subsection|Coordinates>

  <subsubsection|Coordinates, pixels and rounding>

  All coordinates and sizes are represented by instances of type <verbatim|SI>, which is nothing but another name for <verbatim|int>. The <verbatim|SI> constant <verbatim|PIXEL>, which is a power of two <verbatim|1 \<less\>\<less\> PIXEL_SHIFT> denotes the size of a pixel on the screen. Since <verbatim|PIXEL\<gtr\>1>, coordinates and sizes are not necessarily integer multiples of the pixel size. However, the coordinates of the origin and the size of a widget should always be such multiples.

  In order to achieve this, some rounding functions are provided. The function <verbatim|round (SI&)> rounds the argument to an integer multiple of <verbatim|PIXEL>. Furthermore, the <verbatim|window> member functions\ 

  <\verbatim>
    \ \ \ \ void inner_round (SI& x1, SI& y1, SI& x2, SI& y2);<next-line> \ \ \ void outer_round (SI& x1, SI& y1, SI& x2, SI& y2);
  </verbatim>

  transform a rectangle into a new one with integer multiple of <verbatim|PIXEL> coordinates, which is enclosed <abbr|resp.> encloses the original rectangle.

  <subsubsection|Local and global coordinates>

  Each widget has an origin <verbatim|(ox,oy)> with respect to the window to which it has been attached. This is the origin of the “local coordinates”. The origin of the “global coordinates” is the origin of the window. The location of the local origin in the widget is determined by the widget's gravity, which is either one of <verbatim|north_west>, <verbatim|north>, <verbatim|north_east>, <verbatim|west>, <verbatim|center>, <verbatim|east>, <verbatim|south_west>, <verbatim|south> or <verbatim|south_east>.

  As a general rule, events are transmitted in global coordinates. Nevertheless, in widgets which are derived from the abstract basic widget class, by default, all computations are done with respect to local coordinates. This is due to two reasons

  <\itemize>
    <item>When an event has to be processed, the abstract widget event handler translates global into local coordinates and calls the appropriate virtual event handler using local coordinates.

    <item>When an event has to be emitted, the abstract widget provides event construction routines w.r.t. local coordinates, which override the global event construction routines w.r.t global coordinates.
  </itemize>

  <subsubsection|Screen coordinates>

  For some very particular purposes, such as popping up windows, one has to perform computations with respect to the screen coordinates. Given a point <verbatim|(x,y)> in the coordinates of some window <verbatim|win>, the screen coordinates of <verbatim|(x,y)> are obtained by adding the windows origin, which is obtained by calling <verbatim|win-\<gtr\>get_position (ox,oy)>.

  <subsection|Attaching and positioning widgets>

  <subsubsection|Attaching widgets>

  When a widget is created, the <verbatim|win> field of its representation is set to <verbatim|NULL>, since it is not yet attached to a window. In order to attach a widget <verbatim|w> to a window <verbatim|win>, one emits an <verbatim|attach_window_event>:\ 

  <\verbatim>
    \ \ \ \ w \<less\>\<less\> emit_attach_window (win);
  </verbatim>

  Notice that taking <verbatim|win==NULL> results in detaching the widget. Notice also that a widget may be attached to at most one window: attempts to reattach a widget, which is already attached, to another window, result in a fatal error.

  Some events can be handled by widgets which are not yet attached to a window, such as:

  <\itemize>
    <item>“get size” events, which determine the default, minimal and maximal size of a widget. Such an event is generated before the creation of the window to which the widget will be attached in order to determine the size of the window.

    <item>“attach window” events, in order to attach (or detach) a window.

    <item>Events for setting (and getting) attributes: after the creation of a widget some attributes of the widget may be given some default value. In order to change them, one might wish to set them to other values before attaching the widget to a window.

    <item>Events for modifying the composite structure of a widget: these events are used for instance in order to construct menus.
  </itemize>

  For some of these events, such as attribute changes, it may be necessary to emit invalidate events in case when the widget had been attached to some window. In order to test this one uses the member function\ 

  <\verbatim>
    \ \ \ \ bool widget_rep::attached ();
  </verbatim>

  \;

  <subsubsection|Positioning widgets>

  When an appropriate size <verbatim|(w,h)> has been determined for a widget (using “get size” events) and when a widget has been attached to some window, the widget is positioned in the main window. By default, all children are recursively positioned at the top left of the window at sizes <verbatim|(w,h)>. But for complex widgets with children, a specific positioning routine usually has to be implemented.

  Such a routine involves positioning of the children within the parent. This is done by emitting position events to the children. For instance,\ 

  <\verbatim>
    \ \ \ \ a[i] \<less\>\<less\> emit_position (x[i], y[i], w[i], h[i], center);
  </verbatim>

  positions the <verbatim|i>-th child, such that the origin of <verbatim|a[i]> is at position <verbatim|(x[i], y[i])> w.r.t. the local coordinates of <verbatim|this> and such that the origin is situated in the center of <verbatim|a[i]>. The width and height of <verbatim|a[i]> are set to <verbatim|w[i]> <abbr|resp.> <verbatim|h[i]>.

  <subsubsection|Repositioning widgets>

  During execution, it may happen that a particular widget has changed, so that it obtains a different size and/or position. In this case, one emits an <verbatim|update_event> to the closest ancestor, whose position and size did not change.

  For instance, consider the case of a footer <verbatim|footer>, which consists of a left footer <verbatim|footer["left"]>, followed by some glue <verbatim|footer["middle"]> and a right footer <verbatim|footer["right"]>. When the left footer changes:\ 

  <\verbatim>
    \ \ \ \ footer \<less\>\<less\> set_widget ("left", text_widget ("new text"));
  </verbatim>

  the size of <verbatim|footer["left"]> changes, and the size and position of the glue should also be changed. Nevertheless, the size and position of <verbatim|footer> remain unaltered, whence we update <verbatim|footer>:\ 

  <\verbatim>
    \ \ \ \ footer \<less\>\<less\> emit_update ();
  </verbatim>

  \;

  Updating an attached widget results in three actions to take place:

  <\itemize>
    <item>The widget is reattached to its own window. Indeed, some children of the widget might need be attached.

    <item>The widget is repositioned at its current position and size. Again this will actually affect the children.

    <item>The widget is invalidated, so that it will be repainted.
  </itemize>

  <subsection|The keyboard>

  <subsubsection|Keyboard focus>

  Each window <verbatim|win> on the screen determines a main widget <verbatim|win-\<gtr\>w> which is attached to it and a descendant <verbatim|win-\<gtr\>kbd_focus> of this widget, which handles the keyboard input directed to the window. This latter widget <verbatim|win-\<gtr\>kbd_focus>, which is set to <verbatim|win-\<gtr\>w> by default, is said to have keyboard focus, if the window <verbatim|win> has keyboard focus (i.e. if all keyboard events are sent to this window). Consequently, the widget which has keyboard focus receives all keyboard events.

  When the keyboard focus of a window <verbatim|win> changes, a <verbatim|keyboard_focus_event> is sent to <verbatim|win-\<gtr\>kbd_focus>. The field <verbatim|ev-\<gtr\>flag> of this event <verbatim|ev> is <verbatim|TRUE> if the window got the focus, and <verbatim|FALSE> if the window lost focus.

  The keyboard focus widget <verbatim|win-\<gtr\>kbd_focus> associated to a window can be changed by calling the <verbatim|window_rep> member function\ 

  <\verbatim>
    \ \ \ \ void window_rep::set_keyboard_focus (widget);
  </verbatim>

  Setting the input focus to another widget than <verbatim|win-\<gtr\>w> is useful, for instance, if a particular text input field of some form needs keyboard focus after a mouse click on it.

  <subsubsection|Keyboard events>

  When a widget has the keyboard focus, and a key is pressed, it receives a <verbatim|keypress_event>. The <verbatim|keypress_event_rep> class contains a field <verbatim|key>, which contains a comprehensible string corresponding to the key which was pressed.

  More precisely, <verbatim|key> is either a one character string, or a symbolic name like <verbatim|"\<less\>return\<gtr\>">, <verbatim|"\<less\>right\<gtr\>">, <verbatim|"\<less\>del\<gtr\>">, etc. or a composed name like <verbatim|"\<less\>shift-F1\<gtr\>">, <verbatim|"\<less\>ctrl-esc\<gtr\>"> or <verbatim|"\<less\>meta-x\<gtr\>">. The complete list of keys is as follows:\ 

  <\verbatim>
    \ \ \ \ "\<less\>F1\<gtr\>", "\<less\>F2\<gtr\>", "\<less\>F3\<gtr\>", "\<less\>F4\<gtr\>", "\<less\>F5\<gtr\>", "\<less\>F6\<gtr\>",<next-line> \ \ \ "\<less\>F7\<gtr\>", "\<less\>F8\<gtr\>", "\<less\>F9\<gtr\>", "\<less\>F10\<gtr\>", "\<less\>F11\<gtr\>", "\<less\>F12\<gtr\>",<next-line> \ \ \ "\<less\>esc\<gtr\>", "\<less\>tab\<gtr\>", "\<less\>less\<gtr\>", "\<less\>gtr\<gtr\>", "\<less\>del\<gtr\>", "\<less\>return\<gtr\>",<next-line> \ \ \ "\<less\>ins\<gtr\>", "\<less\>home\<gtr\>", "\<less\>end\<gtr\>", "\<less\>page-down\<gtr\>", "\<less\>page-up\<gtr\>",<next-line> \ \ \ "\<less\>left\<gtr\>", "\<less\>up\<gtr\>", "\<less\>down\<gtr\>", "\<less\>right\<gtr\>"
  </verbatim>

  The keys <verbatim|"\<less\>less\<gtr\>"> and <verbatim|"\<less\>gtr\<gtr\>"> correspond <abbr|resp.> to <verbatim|"\<less\>"> and <verbatim|"\<gtr\>">. The allowed modifiers are <verbatim|"shift">, <verbatim|"ctrl"> and <verbatim|"meta"> or combinations of these.

  <subsection|The mouse>

  <subsubsection|Mouse events>

  A mouse event <verbatim|ev> occurs on a button change or a mouse movement. The <verbatim|ev-\<gtr\>type> field contains the type of the event and <verbatim|ev-\<gtr\>x> and <verbatim|ev-\<gtr\>y> the corresponding coordinates of the mouse. Finally, the states of the mouse buttons can be questioned using the routine <verbatim|ev-\<gtr\>pressed (string)>.

  The possible values of <verbatim|ev-\<gtr\>type> on button change events are the following:\ 

  <\verbatim>
    \ \ \ \ "press-left", "press-middle", "press-right",<next-line> \ \ \ "release-left", "release-middle", "release-right"
  </verbatim>

  The possible values for mouse movement events are\ 

  <\verbatim>
    \ \ \ \ "move", "enter", "leave"
  </verbatim>

  The <verbatim|"enter"> and <verbatim|"leave"> events occur when the mouse enters <abbr|resp.> leaves the widget. Finally, the states of the left, middle and right mouse buttons can respectively be obtained using the calls\ 

  <\verbatim>
    \ \ \ \ ev-\<gtr\>pressed ("left")<next-line> \ \ \ ev-\<gtr\>pressed ("middle")<next-line> \ \ \ ev-\<gtr\>pressed ("right")<next-line>\ 
  </verbatim>

  <subsubsection|Grabbing the mouse>

  For some applications such as popup menus or scrollbars, it is useful to direct all mouse events to a particular widget <verbatim|w>. This is done by grabbing the mouse by emitting the event\ 

  <\verbatim>
    \ \ \ \ w \<less\>\<less\> emit_grab_mouse (TRUE)
  </verbatim>

  After such a grab, all mouse events are directed to <verbatim|w>, even those events which occurred before the grab (contrary to X Window). The mouse grab is released by\ 

  <\verbatim>
    \ \ \ \ w \<less\>\<less\> emit_grab_mouse (FALSE)
  </verbatim>

  \;

  Actually, the display keeps track of a list of widgets for which a mouse grab occurred: if the mouse is grabbed by widgets <verbatim|w1> next <verbatim|w2>, and again ungrabbed by <verbatim|w2>, then all mouse events are again sent to <verbatim|w1>. This feature is useful for successive grabs by recursive popup menus.

  When a widget <verbatim|w1> grabs the mouse, and a previous mouse grab on a widget <verbatim|w2> is still active, then a <verbatim|"leave"> event is sent to <verbatim|w2> and an <verbatim|"enter"> event to <verbatim|w1>. Similarly, if <verbatim|w1> releases the grab, then a <verbatim|"leave"> event is sent to <verbatim|w1> and an <verbatim|"enter"> event to <verbatim|w2>.

  <subsection|The screen>

  Each window keeps track of a list of rectangles to be repainted (moreover, redundant rectangles are eliminated automatically and adjacent rectangles are transformed in larger rectangles). During the repaint stage in the event loop, the widget is requested to repaint these rectangles.

  <subsubsection|Repainting rectangles>

  The repaint handler takes on input a <verbatim|repaint_event ev>, which determines the rectangle to be repainted. Moreover, <verbatim|repaint_event_rep> contains a boolean field <verbatim|stop>, which can be set in order to indicate that the repaint process was stopped somewhere in the middle.

  Indeed, for widgets which take a long time to be repainted, it may be useful to abort repainting if a key is pressed. The arrival of an event which aborts repainting can be checked directly on the postscript device <verbatim|dev>:\ 

  <\verbatim>
    \ \ \ \ if (dev-\<gtr\>check_event (EVENT_STATUS)) { ... } // CHECK THIS
  </verbatim>

  In the case of a window, such an event may signify that a key has been pressed; in the case of a printer, it might suggest the printer being turned off.

  If the application decides to abort repainting, it sets <verbatim|ev-\<gtr\>stop> to <verbatim|TRUE>. The rectangle which was being repainted is put back on the invalid rectangles list in the event loop; it will be processed again during the next pass through the repaint phase.

  <subsubsection|Invalidation of rectangles>

  When window is mapped on the screen or when a region is exposed, the window interface automatically invalidates the corresponding rectangle. The user may also invalidate a rectangle by using either one of the routines\ 

  <\verbatim>
    \ \ \ \ event emit_invalidate_all ();<next-line> \ \ \ event emit_invalidate (SI x1, SI y1, SI x2, SI y2);
  </verbatim>

  The first routine creates an event to invalidate the entire widget area; the other routine invalidates a specified region.

  <subsection|The toolkit>

  <subsubsection|Other standard widget classes>

  Many widgets from the toolkit are derived from some other standard abstract widget classes, which can handle some other special events.

  <subsubsection|Composite widgets>

  These widgets allow to add or remove children to or from a widget. This makes them particularly useful for menu widgets. They respond to <verbatim|clean>, <verbatim|insert> and <verbatim|remove> events.

  <subsubsection|Attribute widgets>

  These widgets allow to set window attributes of some common types such as integers, strings, commands, points, etc. They can be used for instance to retrieve an input string or in order to set the scroll position in a canvas widget.

  <subsubsection|Glue widgets>

  Glue widgets are created by\ 

  <\verbatim>
    \ \ \ \ widget glue_widget (bool hext=TRUE, bool vext=TRUE, SI w=0, SI h=0);
  </verbatim>

  The first two arguments determine whether the widget is extensible horizontally <abbr|resp.> vertically. The last two elements determine the default and minimal size of the widget.

  <subsubsection|Text widgets>

  Text widgets are created using\ 

  <\verbatim>
    \ \ \ \ widget text_widget (string s);
  </verbatim>

  They just display the text <verbatim|s>.

  <subsubsection|Buttons>

  Two types of buttons have been implemented. First, command buttons are created using\ 

  <\verbatim>
    \ \ \ \ widget command_button (string s, command cmd);
  </verbatim>

  They display the text <verbatim|s> and execute the command <verbatim|cmd> when pressed. Secondly, we implemented popup buttons, which popup some window when pressed. Popup buttons are created by one of\ 

  <\verbatim>
    \ \ \ \ widget pulldown_button (string s, widget m);<next-line> \ \ \ widget pullright_button (string s, widget m);
  </verbatim>

  depending on where the popup window should popup. The main widget attached to the popup window should be created using\ 

  <\verbatim>
    \ \ \ \ widget popup_widget (widget w, gravity quit);
  </verbatim>

  The <verbatim|quit> argument specifies that the popup window should disappear as soon as the pointer leaves the widget in the <verbatim|quit> direction.

  <subsubsection|Menus>

  Horizontal and vertical menus are created using\ 

  <\verbatim>
    \ \ \ \ widget horizontal_menu ();<next-line> \ \ \ widget vertical_menu ();
  </verbatim>

  By default, they are empty. Subsequently, they can be modified as composite widgets.

  <subsubsection|Canvas widgets>

  Canvas widgets are created using\ 

  <\verbatim>
    \ \ \ \ widget canvas_widget (widget w);
  </verbatim>

  Canvas widget consist of a portion of the widget <verbatim|w> and scrollbars, which enable to scroll <verbatim|w>. The events\ 

  <\verbatim>
    \ \ \ \ event set_scrollable (widget w);<next-line> \ \ \ event set_extents \ \ \ (SI ew, SI ey);<next-line> \ \ \ event set_scroll_pos (SI x, SI y);<next-line> \ \ \ event get_extents \ \ \ (SI& ew, SI& eh);<next-line> \ \ \ event get_visible \ \ \ (SI& x1, SI& y1, SI& x2, SI& y2);
  </verbatim>

  enable to change <verbatim|w>, to set the extents of <verbatim|w>, to set the scroll position, to get the extents of <verbatim|w> and to get the rectangle of <verbatim|w>, which is currently visible.

  <subsubsection|Input widgets>

  Input widgets enable to type a string and to retrieve it when finished. They are created using\ 

  <\verbatim>
    \ \ \ \ widget input_text_widget (command call_back);
  </verbatim>

  Some initial text can be put in it using\ 

  <\verbatim>
    \ \ \ \ event set_input_string (string s);
  </verbatim>

  The command <verbatim|call_back> is executed when typing has been finished or aborted (by typing return, escape or ctrl-c). The typed string can then be retrieved using\ 

  <\verbatim>
    \ \ \ \ event get_input_string (string& s);
  </verbatim>

  Usually, the returned <verbatim|s> is a string enclosed between quotes. If typing was aborted, <verbatim|s> contains the string <verbatim|"cancel">.

  <chapter|<TeXmacs> fonts><label|sec-fonts>

  <section|Classical conceptions of fonts>

  The way <TeXmacs> handles fonts is quite different from classical text editors and even from <TeX>. Let us first analyze some classical ways of conceiving fonts.

  <\itemize>
    <item>Physical fonts are just given by the name of a file, which contains a character set, i.e. a list of bitmaps. Usually the size of a character set is limited by 256 (or 65536).

    <item>True type fonts essentially work in the same way, except that the bitmaps can now be computed for any desired size.

    <item>In the X-window system, the name of the font is replaced by a more systematic name, which explicitly contains a certain number of font parameters, such as its size, series and shape. This makes it easier for applications to select an appropriate font. However, character sets are still limited in size.

    <item>In <TeX>, symbols are seen as commands, which select an appropriate physical font (which corresponds to a <verbatim|.tfm> and a <verbatim|.pk> file), based on symbol font declarations and environment variables (such as size, series and shape).
  </itemize>

  Clearly, among all these methods, <TeX> provides the largest flexibility. However, philosophically speaking, we think that it also has some drawbacks:

  <\itemize>
    <item>There is no distinction between usual commands and commands to make symbols: the current time might be considered as a symbol.

    <item>The encoding of the font is fixed by the names of the commands. For instance, for mathematical symbols, no clean general encoding scheme is provided, except the default naming of symbols by commands.

    <item>For beginners, it remains extremely hard to use non standard fonts.
  </itemize>

  Actually, in <TeX>, the notion of “the current font” is ill-defined: it is merely the superposition of all character generating commands.

  <section|The conception of a font in TeXmacs>

  Philosophically speaking, we think that a font should be characterized by the following two essential properties:

  <\enumerate>
    <item>A font associates graphical meanings to <with|font-shape|italic|words>. The words can always be represented by strings.

    <item>The way this association takes place is coherent as a function of the word.
  </enumerate>

  By a word, we either mean a word in a natural language, or a sequence of mathematical, technical or artistic symbols.

  This way of viewing fonts has several advantages:

  <\enumerate>
    <item>A font may take care of kerning and ligatures.

    <item>A font may consist of several “physical fonts”, which are somehow merged together.

    <item>A font might in principle automatically build very complicated glyphs like hieroglyphs or large delimiters from words in a well chosen encoding.

    <item>A font is an irreducible and persistent entity, not a bunch of commands whose actions may depend on some environment.
  </enumerate>

  Notice finally that the “graphical meaning” of a word might be more than just a bitmap: it might also contain some information about a logical bounding box, appropriate places for scripts, etc. Similarly, the “coherence of the association” should be interpreted in its broadest sense: the font might contain additional information for the global typesetting of the words on a page, like the recommended distance between lines, the height of a fraction bar, etc.

  <section|String encodings>

  All text strings in <TeXmacs> consist of sequences of either specific or universal symbols. A specific symbol is a character, different from <verbatim|'\\0'>, <verbatim|'\<less\>'> and <verbatim|'\<gtr\>'>. Its meaning may depend on the particular font which is being used. A universal symbol is a string starting with <verbatim|'\<less\>'>, followed by an arbitrary sequence of characters different from <verbatim|'\\0'>, <verbatim|'\<less\>'> and <verbatim|'\<gtr\>'>, and ending with <verbatim|'\<gtr\>'>. The meaning of universal characters does not depend on the particular font which is used, but different fonts may render them in a different way.

  Universal symbols can also be used to represent mathematical symbols of variable sizes like large brackets. The point here is that the shapes of such symbols depend on certain size parameters, which can not conveniently be thought of as font parameters. This problem is solved by letting the extra parameters be part of the symbol. For instance, <verbatim|"\<less\>left-(-1\<gtr\>"> would be usual bracket and <verbatim|"\<less\>left-(-2\<gtr\>"> a slightly larger one.

  <section|The abstract font class>

  The main abstract <verbatim|font> class is defined in <verbatim|font.hpp>:\ 

  <\cpp-code>
    struct font_rep: rep\<less\>font\<gtr\> {<next-line> \ display \ dis; \ \ \ \ \ \ \ \ \ \ \ \ \ // underlying display<next-line> \ encoding enc; \ \ \ \ \ \ \ \ \ \ \ \ \ // underlying encoding of the font<next-line> \ SI \ \ \ \ \ \ design_size; \ \ \ \ \ // design size in points/256<next-line> \ SI \ \ \ \ \ \ display_size; \ \ \ \ // display size in points/PIXEL<next-line> \ double \ \ slope; \ \ \ \ \ \ \ \ \ \ \ // italic slope<next-line> \ space \ \ \ spc; \ \ \ \ \ \ \ \ \ \ \ \ \ // usual space between words<next-line> \ space \ \ \ extra; \ \ \ \ \ \ \ \ \ \ \ // extra space at end of words<next-line><next-line> \ SI \ \ \ \ \ \ y1; \ \ \ \ \ \ \ \ \ \ \ \ \ \ // bottom y position<next-line> \ SI \ \ \ \ \ \ y2; \ \ \ \ \ \ \ \ \ \ \ \ \ \ // top y position<next-line> \ SI \ \ \ \ \ \ yfrac; \ \ \ \ \ \ \ \ \ \ \ // vertical position fraction bar<next-line> \ SI \ \ \ \ \ \ ysub; \ \ \ \ \ \ \ \ \ \ \ \ // base line for subscripts<next-line> \ SI \ \ \ \ \ \ ysup; \ \ \ \ \ \ \ \ \ \ \ \ // base line for superscripts<next-line><next-line> \ SI \ \ \ \ \ \ wpt; \ \ \ \ \ \ \ \ \ \ \ \ \ // width of one point in font<next-line> \ SI \ \ \ \ \ \ wquad; \ \ \ \ \ \ \ \ \ \ \ // wpt * design size in points<next-line> \ SI \ \ \ \ \ \ wunit; \ \ \ \ \ \ \ \ \ \ \ // unit width for extendable fonts<next-line> \ SI \ \ \ \ \ \ wfrac; \ \ \ \ \ \ \ \ \ \ \ // width fraction bar<next-line> \ SI \ \ \ \ \ \ wsqrt; \ \ \ \ \ \ \ \ \ \ \ // width horzontal line in square root<next-line> \ SI \ \ \ \ \ \ wneg; \ \ \ \ \ \ \ \ \ \ \ \ // width of negation line<next-line><next-line> \ font_rep (display dis, string name);<next-line> \ font_rep (display dis, string name, font fn);<next-line> \ void copy_math_pars (font fn);<next-line><next-line> \ virtual void \ \ get_extents (string s, text_extents& ex) = 0;<next-line> \ virtual void \ \ draw (ps_device dev, string s, SI x, SI y) = 0;<next-line><next-line> \ virtual SI \ \ \ \ get_sub_base (string s);<next-line> \ virtual SI \ \ \ \ get_sup_base (string s);<next-line> \ virtual double get_left_slope \ (string s);<next-line> \ virtual double get_right_slope (string s);<next-line> \ virtual SI \ \ \ \ get_left_correction \ (string s);<next-line> \ virtual SI \ \ \ \ get_right_correction (string s);<next-line> \ virtual SI \ \ \ \ get_lsub_correction (string s, double level);<next-line> \ virtual SI \ \ \ \ get_lsup_correction (string s, double level);<next-line> \ virtual SI \ \ \ \ get_rsub_correction (string s, double level);<next-line> \ virtual SI \ \ \ \ get_rsup_correction (string s, double level);<next-line><next-line> \ void var_get_extents (string s, text_extents& ex);<next-line> \ void var_draw (ps_device dev, string s, SI x, SI y);<next-line> \ virtual bitmap_char get_bitmap (string s);<next-line>};
  </cpp-code>

  <\verbatim>
    \ \ \ \ 
  </verbatim>

  The main abstract routines are <verbatim|get_extents> and <verbatim|draw>. The first routine determines the logical and physical bounding boxes of a graphical representation of a word, the second one draws the string on the the screen.

  The additional data are used for global typesetting using the font. The other virtual routines are used for determining additional properties of typeset strings.

  <section|Implementation of concrete fonts>

  Several types of concrete fonts have been implemented in <TeXmacs>:

  <\description>
    <item*|TeX text fonts>See <verbatim|src/Resource/Fonts/tex_font.cc>.

    <item*|TeX rubber fonts>See <verbatim|src/Resource/Fonts/tex_rubber_font.cpp>.

    <item*|X fonts>See <verbatim|src/Resource/Fonts/ps_font.cpp>.

    <item*|Mathematical fonts>See <verbatim|src/Resource/Fonts/math_font.cpp>.

    <item*|Virtual fonts>See <verbatim|src/Resource/Fonts/virtual_font.cpp>.
  </description>

  In most cases, the lowest layer of the implementation consists of a collection of bitmaps, together with some font metric information. The font is responsible for putting these bitmaps together on the screen using some appropriate spacing. The <verbatim|ps_device> class comes with a method to display bitmaps in a nice, anti-aliased way, or to print them out.

  <section|Font selection>

  After having implemented fonts themselves, an important remaining issue is the selection of the appropriate font as a function of a certain number of parameters, such as its name, series, shape and size. For optimal flexibility, <TeXmacs> comes with a powerful macro-based font-selection scheme (using the <scheme> syntax), which allows the user to decide which parameters should be considered meaningful.

  At the lowest level, we provide a fixed number of macros which directly correspond to the above types of concrete fonts. For instance, the macro\ 

  <\scm>
    \ \ \ \ (tex $name $size $dpi)
  </scm>

  corresponds to the constructor

  <\cpp-code>
    font tex_font (display dis, string fam, int size, int dpi, int dsize=10);
  </cpp-code>

  of a <TeX> text font.

  At the middle level, it is possible to specify some rewriting rules like\ 

  <\scm-code>
    ((roman rm medium right $s $d) (ec ecrm $s $d))

    ((avant-garde rm medium right $s $d) (tex rpagk $s $d 0))

    ((x-times rm medium right $s $d) (ps adobe-times-medium-r-normal $s $d))
  </scm-code>

  When a left hand pattern is matched, it is recursively substituted by the right hand side. The files in the directory <verbatim|progs/fonts> contain a large number of rewriting rules.

  At the top level, <TeXmacs> calls a macro of the form\ 

  <\scm-code>
    ($name $family $series $shape $size $dpi)
  </scm-code>

  as a function of the current environment in the text. In the future, the top level macro call might change in order to enable the user to let the font depend on other environment variables.

  <chapter|Mathematical typesetting><label|sec-maths>

  <section|Introduction>

  In this chapter we describe the algorithms used by <TeXmacs> in order to typeset mathematical formulas. This is a difficult subject, because esthetics and effectiveness do not always go hand in hand. Until now, <TeX> is widely accepted for having achieved an optimal compromise in this respect. Nevertheless, we thought that several improvements could still be made, which have now been implemented in <TeXmacs>. We will shortly describe the motivations behind them.

  In order to obtain esthetic formulas, what criteria should we use? It is often stressed that good typesetting allows the reader to concentrate on what he reads, without being distracted by ugly typesetting details. Such distracting details arise when distinct, though similar parts of text are typeset in a non uniform way:

  <\description>
    <item*|Different base lines>The eye expects text of a similar nature to be typeset with respect to a same base line. For instance, in <math|x+y+z>, the bottoms of the <math|x> and <math|z> should be at the same height as the bottom of the <math|u>-part in the <math|y>. This should again be the case in <math|2<rsup|x>+2<rsup|y>+2<rsup|z>>.

    <item*|Unequal spacing>Different components of text with approximately the same function should be separated by equal amounts of space. For instance, in <math|a<rsup|2>+f<rsup|2>>, the typesetter should notice the hangover of the <math|f>. This should again be the case in <math|e<rsup|a>+e<rsup|f>+e<rsup|x>>. Similarly, the distance between the baselines of the <math|a> and the <math|i> in <math|a<rsub|i>> should not be disproportionally large with respect to the height of an <math|x>.
  </description>

  Additional difficulties may arise when considering automatically generated formulas, in which case line breaking has to be dealt with in a satisfactory way.

  Unfortunately, the different esthetic criteria may enter into conflict with each other. For instance, consider the formula <math|x<rsub|p>+x<rsub|p><rsup|2>>. On the one hand, the baselines of the scripts should be the same, but the other hand, the first subscript should not be “disproportionally low” with respect to the <math|x>. Unfortunately, this dilemma can not been solved in a completely satisfactory way without the help of a human for the simple reason that the computer has no way to know whether the <math|x<rsub|p>> and <math|x<rsub|p><rsup|i>> are “related”. Indeed, if the <math|x<rsub|p>> and <math|x<rsub|p><rsup|i>> are close (like in <math|x<rsub|p>+x<rsub|p><rsup|i>>), then it is natural to opt for a common base line. However, if they are further away from each other (like in <math|x<rsub|p>+<big|sum><rsub|i=0><rsup|\<infty\>>c<rsub|i>x<rsub|p><rsup|i>>), then we might want to opt for different base lines and locally optimize the rendering of the first <math|x<rsub|p>>.

  Consequently, <TeXmacs> should offer a reasonable compromise for the most frequent cases, while offering methods for the user to make finer adjustments in the remaining ones. We provide the constructs <menu|Format|Adjust|Move> and <menu|Format|Adjust|Resize> to move and resize boxes in order to perform such adjustments. For instance, if the brackets around the two sums

  <\equation*>
    \<phi\><around*|(|<big|sum><rsub|i>a<rsub|i>x<rsup|i>|)>=\<psi\><around*|(|<big|sum><rsub|<smash|j>>b<rsub|j>y<rsup|j>|)>
  </equation*>

  have different sizes, then one may resize the bottom of the subscript <math|j> of the second sum to <verbatim|0fn>. Alternatively, one may resize the bottoms of both the <math|i> and <math|j> subscripts to (say) <verbatim|-0.3fn>. For easier adjustments you may use <menu|Format|Adjust|Smash> and <menu|Format|Adjust|Inflate> to automatically adjust the size of the contents to the height of the character “x” and the largest one in the font respectively.

  Notice that one should adjust by preference in a structural and not visual way. For instance, one should prefer <verbatim|-0.3fn> to <verbatim|-2mm> in the above example, because the second option disallows you to switch to another font size for your document. Similarly, you should try not change the semantics of the formula. For instance, in the above example, you might have added a “dummy subscript” to the <math|i> subscript of the sum. However, this would alter the meaning of the formula (whence make it non suitable as input to a computer algebra system) In the future, we plan to provide additional constructs in order to facilitate structural adjusting. For instance, in the case of a formula like

  <\equation*>
    1+x<rsub|1>+x<rsub|1><rsup|2>+\<cdots\>+x<rsub|2>+x<rsub|1>x<rsub|2>+x<rsub|1><rsup|2>x<rsub|2>+\<cdots\>x<rsub|2><rsup|2>+x<rsub|1>x<rsub|2><rsup|2>+x<rsub|1><rsup|2>x<rsub|2><rsup|2>+\<cdots\>,
  </equation*>

  one might think of a construct to enclose the entire formula into an area, where all scripts are forced to be double (using dummy superscripts wherever necessary).

  <section|The font parameters>

  Several font parameters are crucial for the correct positioning of the different components. The following are often needed:

  <\description>
    <item*|<verbatim|quad>>The main font reference space <verbatim|1fn>, which can be taken as the distance between successive lines of text.

    <item*|<verbatim|y1> and <verbatim|y2>>The bottom and top level for the font (we have <verbatim|y2-y1=quad>).

    <item*|<verbatim|sep>>The reference minimal space between distinct components, like the minimal distance between a subscript and a superscript. In fact, <verbatim|sep=quad/10>.

    <item*|<verbatim|wline>>The width of several types of lines, like the fraction and square root bars, wide accents, etc.

    <item*|<verbatim|yfrac>>The height of the fraction bar, which is needed for the positioning of fractions and big delimiters. Usually, <verbatim|yfrac> is almost equal to <verbatim|yx/2> below.
  </description>

  The following parameters are mainly needed in order to deal with scripts:

  <\description>
    <item*|<verbatim|yx>>The height of the <math|x> character, which is needed for the positioning of scripts. All the remaining parameters are actually computed as a function of <verbatim|yx>.

    <item*|<verbatim|ysub lo base>>Logical base line for subscripts.

    <item*|<verbatim|ysub hi lim>>Subscripts may never physically exceed this top height.

    <item*|<verbatim|ysup lo base>>Logical base line for superscripts.

    <item*|<verbatim|ysup lo lim>>Superscripts may never physically exceed this bottom height.

    <item*|<verbatim|ysup hi lim>>Suggestion for a physical top line for superscripts.

    <item*|<verbatim|yshift>>Possible shift of the base lines when we are inside fractions or scripts.
  </description>

  The individual strings in a font also have several important positioning properties. First of all, they always admit left and right slopes. Furthermore, they admit left and right italic corrections, which are needed for the positioning of scripts or when passing from text in upright to text in italics (or vice versa).

  <section|Some major mathematical constructs>

  <subsection|Fractions>

  The following heuristics are used:

  <\itemize>
    <item>The horizontal middles of the numerator and the denominator are taken to be the same.

    <item>The vertical spaces between the numerator <abbr|resp.> denominator and the fraction bar is at least <verbatim|sep>.

    <item>The depth (<abbr|resp.> height) of the numerator (<abbr|resp.> denominator) is descended (<abbr|resp.> increased) to <verbatim|y1> (<abbr|resp.> <verbatim|y2>) if necessary. This forces the base lines of not too large numerators <abbr|resp.> denominators to be the same in presence of multiple fractions.

    <item>The fraction bar has a overhang of <verbatim|sep/2> to both sides and the logical limits of the fraction are another <verbatim|sep/2> further. The logical left limit is zero.
  </itemize>

  The italic corrections are not taken into account during the positioning algorithms, because this may create the impression that the numerator and denominator are not correctly centered with respect to each other. Nevertheless, the italic corrections are taken into account in order to compute the logical bounding box of the fraction (whose has italic slopes vanish at both sides).

  <subsection|Roots>

  The following heuristics are used:

  <\itemize>
    <item>The vertical space between the main argument and the upper bar is at least <verbatim|sep>.

    <item>The root itself is typeset like a large delimiter. The positioning of a potential script works only is very dependent on the usage of <TeX> fonts.

    <item>The upper bar has a overhang of <verbatim|sep/2> at the right and the logical right limit of the root is situated another <verbatim|sep/2> further to the right.
  </itemize>

  We take the logical right border plus the italic correction of the main argument in order to determine the right hand limit of the upper bar. The left italic correction is not needed.

  <subsection|Negations>

  The following heuristics are used:

  <\itemize>
    <item>The negation bar passes through the logical center of the argument.

    <item>The italic corrections of the argument are only taken into account during the computation of the logical limits of the negation box (which has zero left and right slopes).
  </itemize>

  <subsection|Wide boxes>

  The following heuristics are used:

  <\itemize>
    <item>We use <TeX> fonts for small accents and an <with|font-shape|italic|ad hoc> algorithm for the wider ones.

    <item>The distance between the main argument and the accent is at least <verbatim|sep> (or a distance which depends on the <TeX> font for small accents).

    <item>The accent is positioned horizontally according to the right slope of the main argument.

    <item>The slopes for the accented box are inherited from those of the main argument and the italic corrections are adjusted accordingly.

    <item>All script height parameters of the accented box are inherited from the main argument. The only exception is <verbatim|ysup_hi_lim>, which may be increased by the height of the accent, or determined in the generic way, whichever leads to the least value. It is indeed better to keep superscripts positioned reasonably low, whenever possible.
  </itemize>

  <section|Subscripts and superscripts>

  The positioning of subscripts and superscripts is a complicated affair, due to the conflict between locally and globally optimal esthetics mentioned above. The base line for a subscript is determined as follows:

  <\enumerate>
    <item>Always pretend that the subscript has height at least <verbatim|y2-yshift> in the script font (actually we should use the height of an <math|M> instead).

    <item>Try to position the script at the base line given by the main argument.

    <item>If the top limit (given by the main argument) is physically exceeded by the subscript, then the base line is moved further down accordingly.
  </enumerate>

  The base line for a superscript is determined as follows:

  <\enumerate>
    <item>Try to physically position the superscript beneath the suggested top line. Usually, this will place the superscript to far down.

    <item>Move the superscript up to the logical base line if necessary. This will usually occur: most of the time, the logical base line is the just the height of an <math|x>-script below the suggested top line.

    <item>If the superscript physically descends below the physical under limit given by the main box, then we move the superscript further upwards.
  </enumerate>

  If both a subscript and a superscript were present, then we still have to adjust the base lines: if the top of the subscript and the bottom of the superscript are not physically separated by <verbatim|sep>, then we both move the subscript and the superscript by the same amount away from each other. Because of step 1 in the positioning of the subscript, the base lines of double scripts will usually be the same in formulas with several of them.

  The right slope and italic correction of a script box may be non trivial. In order to compute them, we first determine the script (or main argument), whose right limit (taking into account its italic correction) is furthest to the right (this may be the main box, in the case of a big integral with a tiny subscript). Then the right slope of the main box is inherited by the right slope of this script (or main argument). As to the italic correction, it is precisely the difference between the right offset of the script plus its italic correction minus the logical right coordinate of the entire box. The italic correction should be at least zero though. The left slope and italic correction are computed in a similar way.

  <section|Big delimiters>

  The automatic positioning and computation of sizes of big delimiters is again complicated because of potential conflicts between locally and globally optimal esthetics.

  First of all, <TeX> fonts come only with a discrete set of possible sizes for large delimiters. This is an advantage from the point of view that it favorites delimiters around slightly different expressions to have the same baselines. However, it has the disadvantage that delimiters are easily made “one size to large”. For this reason, we actually diminish the height and the depth of the delimited expression by the small amount <verbatim|sep>, before computing the sizes of the delimiters.

  Secondly, it is best when the vertical middles of big delimiters occur at the height of fraction bars. However, in a formula like

  <\equation*>
    f<around*|(|<frac|1|1+<frac|1|1+<frac|1|1+<frac|1|x>>>>|)>,
  </equation*>

  it may be worth it to descend the delimiters a bit. On the other hand, slight vertical shifts in the middles of the delimiters potentially have a bad effect on base lines, like in

  <\equation*>
    f<around*|(|<big|sum><rsub|i=1><rsup|b>X<rsub|i>|)>+g<around*|(|<big|sum><rsub|j=1><rsup|a>Y<rsub|j>|)>.
  </equation*>

  In <TeXmacs>, we use the following compromise: we start with the middle of the delimited expression as a first approximation to the middle of the delimiters. The real middle is obtained by shifting this middle towards the height of fraction bars by an amount which cannot exceed <verbatim|sep>.

  From a horizontal point of view, we finally have to notice that we adapted the metrics of the big delimiters in a way that potential scripts are positioned in a better way. For instance, according to the <TeX> <verbatim|tfm> file, in a formula like

  <\equation*>
    <around*|(|A+<around*|(|<big|sum><rsub|i=1><rsup|10>B<rsub|i>|)><rsup|2>|)>,
  </equation*>

  the square rather seems to be a left superscript of the second closing bracket than a right superscript of the first one. This is particularly annoying in the case of automatically generated formulas, where this situation occurs quite often.

  <chapter|The boxes produced by the typesetter><label|sec-boxes>

  <section|Introduction>

  The <TeXmacs> typesetter essentially translates a document represented by a tree into a graphical box, which can either be displayed on the screen or on a printer. Contrary to a system like <LaTeX>, the graphical box actually contains much more information than is necessary for a graphical rendering. Roughly speaking, this information can be subdivided into the following categories:

  <\itemize>
    <item>Logical and physical bounding boxes.

    <item>A method for graphical rendering.

    <item>Miscellaneous typesetting information.

    <item>Keeping track of the source subtree which led to the box.

    <item>Computing the positions of cursors and selections.

    <item>Event handlers for dynamic content.
  </itemize>

  The logical bounding box is used by the typesetter to position the box with respect to other boxes. A certain amount of other information, such as the slant of the box, is also stored for the typesetter. The physical bounding box encloses the graphical representation of the box. This knowledge is needed when partially redrawing a box in an efficient way.

  In order to position the cursor or when making a selection, it is necessary to have a correspondence between logical positions in the source tree and physical positions in the typeset boxes. More precisely, boxes and their subboxes are logically organized as a tree. Boxes provide routines to translate between paths in the box tree and the source tree and to find the path which is associated to a graphical point.

  <section|The correspondence between a box and its source>

  <subsection|Discussion of the problems being encountered>

  In order to implement the correspondence between paths in the source tree and the box tree, one has to face several simultaneous difficulties:

  <\enumerate>
    <item>Due to line breaking, footnotes and macro expansions, the correspondence may be non straightforward.

    <item>The correspondence has to be reasonably time and space efficient.

    <item>Some boxes, such header and footers, or certain results of macro expansions, may not be “accessible”. Although one should be able to find a reasonable cursor position when clicking on them, the contents of this box can not be edited directly.

    <item>The correspondence has to be reasonably complete (see the next section).
  </enumerate>

  The first difficulty forces us to store a path in the source tree along with any box. In order to save storage, this path is stored in a reversed manner, so that common heads can be shared. This common head sharing is also necessary to quickly change the source locations when modifying the source tree, for instance by inserting a new paragraph.

  In order to cope with the third difficulty, the inverse path may start with a negative number, which indicates that the box can not directly be edited (we also say that the box is a decoration). In this case, the tail of the inverse path corresponds to a location in the source tree, where the cursor should be positioned when clicking on the box. The negative number influences the way in which this is done.

  <subsection|The three kinds of paths>

  More precisely, we have to deal with three kinds of paths:

  <\description>
    <item*|Tree paths>These paths correspond to paths in the source tree. Actually, the path minus its last item points to a subtree of the source tree. The last item gives a position in this subtree: if the subtree is a leaf, i.e. a string, it is a position in this string. Otherwise a zero indicates a position before the subtree and a one a position after the subtree.

    <item*|Inverse paths>These are just reverted tree paths (with shared tails), with an optional negative head. A negative head indicates that the tree path is not accessible, i.e. the corresponding subtree does not correspond to editable content. If the negative value is <math|-2>, <math|-3> or <hgroup|<math|-4>>, then a zero or one has to be put behind the tree path, depending on the value and the cursor position.

    <item*|Box paths>These paths correspond to logical paths in the box tree. Again, the path minus its last item points to a subbox of the main box, and the last item gives a position in this subtree: if the subbox corresponds to a text box it is a position in this text. Otherwise a zero indicates a position before the subbox and a one a position after it. In the case of side boxes, a two and a three may also indicate the position after the left script <abbr|resp.> before the right script.
  </description>

  <subsection|The conversion routines>

  In order to implement the conversion between the three kinds of paths, every box comes with a reference inverse path <verbatim|ip> in the source tree. Composite boxes also come with a left and a right inverse path <verbatim|lip> <abbr|resp.> <verbatim|rip>, which correspond to the left-most and right-most accessible paths in its subboxes (if there are such subboxes).

  The routine:

  <\verbatim>
    \ \ \ \ virtual path box_rep::find_tree_path (path bp)
  </verbatim>

  transforms a box path into a tree path. This routine (which only uses <verbatim|ip>) is fast and has a linear time complexity as a function of the lengths of the paths. The routine:\ 

  <\verbatim>
    \ \ \ \ virtual path box_rep::find_box_path (path p)
  </verbatim>

  does the inverse conversion. Unfortunately, in the worst case, it may be necessary to search for the matching tree path in all subboxes. Nevertheless, in the best case, a dichotomic algorithm (which uses <verbatim|lip> and <verbatim|rip>), finds the right branch how to descend in a logarithmic time. This algorithm also has a quadratic time complexity as a function of the lengths of the paths, because we frequently need to revert paths.

  <section|The cursor and selections>

  In order to fulfill the requirement of being a “structured editor”, <TeXmacs> needs to provide a (reasonably) complete correspondence between logical tree paths and physical cursor positions. This yields an additional difficulty in the case of “environment changes”, such as a change in font or color. Indeed, when you are on the border of such a change, it is not clear <with|font-shape|italic|a priori> which environment you are in.

  In <TeXmacs>, the cursor position therefore contains an <math|x> and a <math|y> coordinate, as well as an additional infinitesimal <math|x>-coordinate, called <math|\<delta\>>. A change in environment is then represented by a box with an infinitesimal width. Although the <math|\<delta\>>-position of the cursor is always zero when you select using the mouse, it may be non zero when moving around using the cursor keys. The linear time routine:\ 

  <\verbatim>
    \ \ \ \ virtual path box_rep::find_box_path (SI x, SI y, SI delta)
  </verbatim>

  as a function of the length of the path searches the box path which corresponds to a cursor position. Inversely, the routine:\ 

  <\verbatim>
    \ \ \ \ virtual cursor box_rep::find_cursor (box bp)
  </verbatim>

  yields a graphical representation for the cursor at a certain box path. The cursor is given by its <math|x>, <math|y> and <math|\<delta\>> coordinates and a line segment relative to this origin, given by its extremities <math|<around|(|x<rsub|1>,y<rsub|1>|)>> and <math|<around|(|x<rsub|2>,y<rsub|2>|)>>.

  In a similar way, the routine:\ 

  <\verbatim>
    \ \ \ \ virtual selection box_rep::find_selection (box lbp, box rbp)
  </verbatim>

  computes the selection between two given box paths. This selection comprises two delimiting tree paths and a graphical representation in the form of a list of rectangles.

  <\the-index|idx>
    <index+1*|<with|font-family|ss|Format>>

    <index+2*|<with|font-family|ss|Format>|<with|font-family|ss|Adjust>>

    <index+3|<with|font-family|ss|Format>|<with|font-family|ss|Adjust>|<with|font-family|ss|Inflate>|<pageref|auto-76>>

    <index+3|<with|font-family|ss|Format>|<with|font-family|ss|Adjust>|<with|font-family|ss|Move>|<pageref|auto-73>>

    <index+3|<with|font-family|ss|Format>|<with|font-family|ss|Adjust>|<with|font-family|ss|Resize>|<pageref|auto-74>>

    <index+3|<with|font-family|ss|Format>|<with|font-family|ss|Adjust>|<with|font-family|ss|Smash>|<pageref|auto-75>>
  </the-index>
</body>

<\initial>
  <\collection>
    <associate|page-medium|paper>
  </collection>
</initial>

<\references>
  <\collection>
    <associate|auto-1|<tuple|1|7>>
    <associate|auto-10|<tuple|2.2|11>>
    <associate|auto-11|<tuple|2.3|12>>
    <associate|auto-12|<tuple|2.4|12>>
    <associate|auto-13|<tuple|2.5|12>>
    <associate|auto-14|<tuple|3|13>>
    <associate|auto-15|<tuple|3.1|13>>
    <associate|auto-16|<tuple|3.2|13>>
    <associate|auto-17|<tuple|3.3|14>>
    <associate|auto-18|<tuple|4|15>>
    <associate|auto-19|<tuple|4.1|15>>
    <associate|auto-2|<tuple|1.1|7>>
    <associate|auto-20|<tuple|4.1.1|15>>
    <associate|auto-21|<tuple|4.1.1.1|16>>
    <associate|auto-22|<tuple|4.1.2|16>>
    <associate|auto-23|<tuple|4.1.2.1|17>>
    <associate|auto-24|<tuple|4.2|18>>
    <associate|auto-25|<tuple|4.2.1|18>>
    <associate|auto-26|<tuple|4.3|18>>
    <associate|auto-27|<tuple|4.3.1|18>>
    <associate|auto-28|<tuple|4.3.1.1|18>>
    <associate|auto-29|<tuple|4.3.1.2|19>>
    <associate|auto-3|<tuple|1.2|7>>
    <associate|auto-30|<tuple|4.3.2|19>>
    <associate|auto-31|<tuple|4.3.2.1|19>>
    <associate|auto-32|<tuple|4.3.2.2|20>>
    <associate|auto-33|<tuple|4.3.2.3|20>>
    <associate|auto-34|<tuple|4.3.2.4|21>>
    <associate|auto-35|<tuple|4.3.2.5|22>>
    <associate|auto-36|<tuple|4.3.3|22>>
    <associate|auto-37|<tuple|4.3.4|22>>
    <associate|auto-38|<tuple|4.3.4.1|22>>
    <associate|auto-39|<tuple|4.3.4.2|23>>
    <associate|auto-4|<tuple|1.2.1|8>>
    <associate|auto-40|<tuple|4.3.4.3|23>>
    <associate|auto-41|<tuple|4.3.5|23>>
    <associate|auto-42|<tuple|4.3.5.1|23>>
    <associate|auto-43|<tuple|4.3.5.2|24>>
    <associate|auto-44|<tuple|4.3.5.3|24>>
    <associate|auto-45|<tuple|4.3.6|25>>
    <associate|auto-46|<tuple|4.3.6.1|25>>
    <associate|auto-47|<tuple|4.3.6.2|25>>
    <associate|auto-48|<tuple|4.3.7|25>>
    <associate|auto-49|<tuple|4.3.7.1|25>>
    <associate|auto-5|<tuple|1.2.2|8>>
    <associate|auto-50|<tuple|4.3.7.2|26>>
    <associate|auto-51|<tuple|4.3.8|26>>
    <associate|auto-52|<tuple|4.3.8.1|26>>
    <associate|auto-53|<tuple|4.3.8.2|26>>
    <associate|auto-54|<tuple|4.3.9|27>>
    <associate|auto-55|<tuple|4.3.9.1|27>>
    <associate|auto-56|<tuple|4.3.9.2|27>>
    <associate|auto-57|<tuple|4.3.9.3|27>>
    <associate|auto-58|<tuple|4.3.9.4|27>>
    <associate|auto-59|<tuple|4.3.9.5|27>>
    <associate|auto-6|<tuple|1.3|8>>
    <associate|auto-60|<tuple|4.3.9.6|27>>
    <associate|auto-61|<tuple|4.3.9.7|28>>
    <associate|auto-62|<tuple|4.3.9.8|28>>
    <associate|auto-63|<tuple|4.3.9.9|28>>
    <associate|auto-64|<tuple|5|29>>
    <associate|auto-65|<tuple|5.1|29>>
    <associate|auto-66|<tuple|5.2|29>>
    <associate|auto-67|<tuple|5.3|30>>
    <associate|auto-68|<tuple|5.4|30>>
    <associate|auto-69|<tuple|5.5|32>>
    <associate|auto-7|<tuple|1.4|8>>
    <associate|auto-70|<tuple|5.6|32>>
    <associate|auto-71|<tuple|6|33>>
    <associate|auto-72|<tuple|6.1|33>>
    <associate|auto-73|<tuple|Unequal spacing|33>>
    <associate|auto-74|<tuple|Unequal spacing|33>>
    <associate|auto-75|<tuple|Unequal spacing|34>>
    <associate|auto-76|<tuple|Unequal spacing|34>>
    <associate|auto-77|<tuple|6.2|34>>
    <associate|auto-78|<tuple|6.3|35>>
    <associate|auto-79|<tuple|6.3.1|35>>
    <associate|auto-8|<tuple|2|11>>
    <associate|auto-80|<tuple|6.3.2|35>>
    <associate|auto-81|<tuple|6.3.3|35>>
    <associate|auto-82|<tuple|6.3.4|36>>
    <associate|auto-83|<tuple|6.4|36>>
    <associate|auto-84|<tuple|6.5|37>>
    <associate|auto-85|<tuple|7|39>>
    <associate|auto-86|<tuple|7.1|39>>
    <associate|auto-87|<tuple|7.2|39>>
    <associate|auto-88|<tuple|7.2.1|39>>
    <associate|auto-89|<tuple|7.2.2|40>>
    <associate|auto-9|<tuple|2.1|11>>
    <associate|auto-90|<tuple|7.2.3|40>>
    <associate|auto-91|<tuple|7.3|41>>
    <associate|auto-92|<tuple|7.3|43>>
    <associate|sec-architecture|<tuple|1|7>>
    <associate|sec-boxes|<tuple|7|39>>
    <associate|sec-conversions|<tuple|3|13>>
    <associate|sec-fonts|<tuple|5|29>>
    <associate|sec-gui|<tuple|4|15>>
    <associate|sec-maths|<tuple|6|33>>
    <associate|sec-types|<tuple|2|11>>
  </collection>
</references>

<\auxiliary>
  <\collection>
    <\associate|idx>
      <tuple|<tuple|<with|font-family|<quote|ss>|Format>|<with|font-family|<quote|ss>|Adjust>|<with|font-family|<quote|ss>|Move>>|<pageref|auto-73>>

      <tuple|<tuple|<with|font-family|<quote|ss>|Format>|<with|font-family|<quote|ss>|Adjust>|<with|font-family|<quote|ss>|Resize>>|<pageref|auto-74>>

      <tuple|<tuple|<with|font-family|<quote|ss>|Format>|<with|font-family|<quote|ss>|Adjust>|<with|font-family|<quote|ss>|Smash>>|<pageref|auto-75>>

      <tuple|<tuple|<with|font-family|<quote|ss>|Format>|<with|font-family|<quote|ss>|Adjust>|<with|font-family|<quote|ss>|Inflate>>|<pageref|auto-76>>
    </associate>
    <\associate|toc>
      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|font-shape|<quote|small-caps>|1.<space|2spc>General architecture of T<rsub|<space|-0.4spc><move|<resize|<with|math-level|<quote|0>|E>||||0.5fn>|0fn|-0.1fn>><space|-0.4spc>X<rsub|<space|-0.4spc><move|<resize|M<space|-0.2spc>A<space|-0.4spc>CS||||0.5fn>|0fn|-0.1fn>>> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <pageref|auto-1><vspace|0.5fn>

      1.1.<space|2spc>Introduction <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-2>

      1.2.<space|2spc>Intern representation of texts <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-3>

      <with|par-left|<quote|1tab>|1.2.1.<space|2spc>Text <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-4>>

      <with|par-left|<quote|1tab>|1.2.2.<space|2spc>The language <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-5>>

      1.3.<space|2spc>Typesetting texts <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-6>

      1.4.<space|2spc>Making modifications in texts <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-7>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|font-shape|<quote|small-caps>|2.<space|2spc>Basic data types> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <pageref|auto-8><vspace|0.5fn>

      2.1.<space|2spc>Memory allocation and data structures in TeXmacs <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-9>

      2.2.<space|2spc>Array-like structures <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-10>

      2.3.<space|2spc>Lists <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-11>

      2.4.<space|2spc>Hash tables <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-12>

      2.5.<space|2spc>Other data structures <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-13>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|font-shape|<quote|small-caps>|3.<space|2spc>Converters to other data formats> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <pageref|auto-14><vspace|0.5fn>

      3.1.<space|2spc>Parsing extern data formats <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-15>

      3.2.<space|2spc>The actual converter <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-16>

      3.3.<space|2spc>Backward conversions <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-17>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|font-shape|<quote|small-caps>|4.<space|2spc>The graphical user interface> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <pageref|auto-18><vspace|0.5fn>

      4.1.<space|2spc>Introduction <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-19>

      <with|par-left|<quote|1tab>|4.1.1.<space|2spc>Main architecture <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-20>>

      <with|par-left|<quote|2tab>|4.1.1.1.<space|2spc>A simple example <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-21>>

      <with|par-left|<quote|1tab>|4.1.2.<space|2spc>Widgets and event processing <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-22>>

      <with|par-left|<quote|2tab>|4.1.2.1.<space|2spc>A simple example <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-23>>

      4.2.<space|2spc>The abstract window interface <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-24>

      <with|par-left|<quote|1tab>|4.2.1.<space|2spc>Displays <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-25>>

      4.3.<space|2spc>Widget principles <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-26>

      <with|par-left|<quote|1tab>|4.3.1.<space|2spc>The widget class <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-27>>

      <with|par-left|<quote|2tab>|4.3.1.1.<space|2spc>The widget representation class <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-28>>

      <with|par-left|<quote|2tab>|4.3.1.2.<space|2spc>The widget class <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-29>>

      <with|par-left|<quote|1tab>|4.3.2.<space|2spc>The event class <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-30>>

      <with|par-left|<quote|2tab>|4.3.2.1.<space|2spc>The event representation class <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-31>>

      <with|par-left|<quote|2tab>|4.3.2.2.<space|2spc>The event class <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-32>>

      <with|par-left|<quote|2tab>|4.3.2.3.<space|2spc>Concrete event classes <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-33>>

      <with|par-left|<quote|2tab>|4.3.2.4.<space|2spc>Event handlers <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-34>>

      <with|par-left|<quote|2tab>|4.3.2.5.<space|2spc>Adding your own event classes <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-35>>

      <with|par-left|<quote|1tab>|4.3.3.<space|2spc>The main event loop <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-36>>

      <with|par-left|<quote|1tab>|4.3.4.<space|2spc>Coordinates <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-37>>

      <with|par-left|<quote|2tab>|4.3.4.1.<space|2spc>Coordinates, pixels and rounding <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-38>>

      <with|par-left|<quote|2tab>|4.3.4.2.<space|2spc>Local and global coordinates <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-39>>

      <with|par-left|<quote|2tab>|4.3.4.3.<space|2spc>Screen coordinates <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-40>>

      <with|par-left|<quote|1tab>|4.3.5.<space|2spc>Attaching and positioning widgets <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-41>>

      <with|par-left|<quote|2tab>|4.3.5.1.<space|2spc>Attaching widgets <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-42>>

      <with|par-left|<quote|2tab>|4.3.5.2.<space|2spc>Positioning widgets <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-43>>

      <with|par-left|<quote|2tab>|4.3.5.3.<space|2spc>Repositioning widgets <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-44>>

      <with|par-left|<quote|1tab>|4.3.6.<space|2spc>The keyboard <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-45>>

      <with|par-left|<quote|2tab>|4.3.6.1.<space|2spc>Keyboard focus <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-46>>

      <with|par-left|<quote|2tab>|4.3.6.2.<space|2spc>Keyboard events <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-47>>

      <with|par-left|<quote|1tab>|4.3.7.<space|2spc>The mouse <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-48>>

      <with|par-left|<quote|2tab>|4.3.7.1.<space|2spc>Mouse events <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-49>>

      <with|par-left|<quote|2tab>|4.3.7.2.<space|2spc>Grabbing the mouse <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-50>>

      <with|par-left|<quote|1tab>|4.3.8.<space|2spc>The screen <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-51>>

      <with|par-left|<quote|2tab>|4.3.8.1.<space|2spc>Repainting rectangles <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-52>>

      <with|par-left|<quote|2tab>|4.3.8.2.<space|2spc>Invalidation of rectangles <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-53>>

      <with|par-left|<quote|1tab>|4.3.9.<space|2spc>The toolkit <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-54>>

      <with|par-left|<quote|2tab>|4.3.9.1.<space|2spc>Other standard widget classes <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-55>>

      <with|par-left|<quote|2tab>|4.3.9.2.<space|2spc>Composite widgets <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-56>>

      <with|par-left|<quote|2tab>|4.3.9.3.<space|2spc>Attribute widgets <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-57>>

      <with|par-left|<quote|2tab>|4.3.9.4.<space|2spc>Glue widgets <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-58>>

      <with|par-left|<quote|2tab>|4.3.9.5.<space|2spc>Text widgets <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-59>>

      <with|par-left|<quote|2tab>|4.3.9.6.<space|2spc>Buttons <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-60>>

      <with|par-left|<quote|2tab>|4.3.9.7.<space|2spc>Menus <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-61>>

      <with|par-left|<quote|2tab>|4.3.9.8.<space|2spc>Canvas widgets <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-62>>

      <with|par-left|<quote|2tab>|4.3.9.9.<space|2spc>Input widgets <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-63>>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|font-shape|<quote|small-caps>|5.<space|2spc>T<rsub|<space|-0.4spc><move|<resize|<with|math-level|<quote|0>|E>||||0.5fn>|0fn|-0.1fn>><space|-0.4spc>X<rsub|<space|-0.4spc><move|<resize|M<space|-0.2spc>A<space|-0.4spc>CS||||0.5fn>|0fn|-0.1fn>> fonts> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <pageref|auto-64><vspace|0.5fn>

      5.1.<space|2spc>Classical conceptions of fonts <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-65>

      5.2.<space|2spc>The conception of a font in TeXmacs <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-66>

      5.3.<space|2spc>String encodings <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-67>

      5.4.<space|2spc>The abstract font class <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-68>

      5.5.<space|2spc>Implementation of concrete fonts <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-69>

      5.6.<space|2spc>Font selection <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-70>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|font-shape|<quote|small-caps>|6.<space|2spc>Mathematical typesetting> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <pageref|auto-71><vspace|0.5fn>

      6.1.<space|2spc>Introduction <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-72>

      6.2.<space|2spc>The font parameters <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-77>

      6.3.<space|2spc>Some major mathematical constructs <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-78>

      <with|par-left|<quote|1tab>|6.3.1.<space|2spc>Fractions <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-79>>

      <with|par-left|<quote|1tab>|6.3.2.<space|2spc>Roots <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-80>>

      <with|par-left|<quote|1tab>|6.3.3.<space|2spc>Negations <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-81>>

      <with|par-left|<quote|1tab>|6.3.4.<space|2spc>Wide boxes <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-82>>

      6.4.<space|2spc>Subscripts and superscripts <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-83>

      6.5.<space|2spc>Big delimiters <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-84>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|font-shape|<quote|small-caps>|7.<space|2spc>The boxes produced by the typesetter> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <pageref|auto-85><vspace|0.5fn>

      7.1.<space|2spc>Introduction <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-86>

      7.2.<space|2spc>The correspondence between a box and its source <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-87>

      <with|par-left|<quote|1tab>|7.2.1.<space|2spc>Discussion of the problems being encountered <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-88>>

      <with|par-left|<quote|1tab>|7.2.2.<space|2spc>The three kinds of paths <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-89>>

      <with|par-left|<quote|1tab>|7.2.3.<space|2spc>The conversion routines <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-90>>

      7.3.<space|2spc>The cursor and selections <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-91>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|font-shape|<quote|small-caps>|Index> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <pageref|auto-92><vspace|0.5fn>
    </associate>
  </collection>
</auxiliary>

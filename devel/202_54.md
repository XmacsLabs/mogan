# [202_54] 新建折叠批注，无法正常插入内容

### 如何测试
在文档中新建comment宏，在`批注`下拉菜单中`新建折叠批注`，输入内容点击`Done`后观察

点击插入的注释符号的位置，观察这一折叠注释是否包含了刚才输入的内容

## 2025/10/5

### What
批注插件comment中，新建折叠批注，无法正常插入内容，`<folded-comment>`节点的body为空

### Why
在`mirror-comment`函数没有正确返回`[unique-id', mirror-id, type, by, time, "", body]`，存在数据传输的错位导致body接收值为空：
```scheme
`(,lab ,id ,@(cDr (cDr (cdr l))) "" ,(cAr l))
```

### How
修改`mirror-comment`函数返回逻辑：
```scheme
(define (mirror-comment t . opt-lab)
  (let* ((uid' (if (tm-atomic? (tm-ref t 0))
                   (string-append (tm->string (tm-ref t 0)) "-edit")
                   (create-unique-id)))
         (mid  (tm->string (tm-ref t 1)))
         (typ  (tm->string (tm-ref t 2)))
         (by   (tm->string (tm-ref t 3)))
         (tim  (tm->string (tm-ref t 4)))
         (bod  (tm-ref t :last))
         (lab  (if (null? opt-lab) 'mirror-comment (car opt-lab))))
    `(,lab ,uid' ,mid ,typ ,by ,tim "" ,bod)))
```
传参时采用：
```scheme
`(,lab ,uid' ,mid ,typ ,by ,tim "" ,bod)
```

并在弹窗关闭时强制更新body内容：
```scheme
(define (comment-editor-done)
  (and-let* ((popup (current-buffer))
             (master (buffer-get-master popup))
             (pc (tree-innermost any-comment-context? #t))
             (mid (and pc (tm->string (tm-ref pc 1))))
             (body (and pc (tm-ref pc :last))))
    (with-buffer master
      (let* ((mb (buffer-get-body master))
             (l (tree-search mb
                             (lambda (t)
                               (and (any-comment-context? t)
                                    (== (tm->string (tm-ref t 1)) mid))))))
        (when (nnull? l)
          (tree-set! (car l) :last (tree-copy body))))))
  (when (defined? 'mirror-treat-pending)
    (mirror-treat-pending))
  (when (defined? 'mirror-synchronize)
    (mirror-synchronize))
  (comment-quit-command))
```
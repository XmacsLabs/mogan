# [201_58] 表格内部格线支持鼠标拖动

## 如何测试
1. 新建任意样式的表格，有框/无框 普通/标宽 均可
2. 光标在单元格上用 `Alt+→`/`Alt+↓` 扩大表格至任意尺寸
3. 光标放在表格内部格线上，光标应该变成对应的样式（水平调整/垂直调整）
4. 拖动光标，相邻的行列单元格的高度/宽度应该随光标位置变化
5. **打开 `TeXmacs/tests/tmu/201_58.tmu` 测试所有表格内线是否能正确拖动调整，尤其是包含子表格的表格**

## 2026/1/20
### What
Fix：子表格中无法检测到鼠标拖动

### How
对于子表格，一定是位于表格 cell 内部，于是在 cell 中调用 `concrete_composite_box_rep::message`：
```cpp
		/* inside area (cells) */
    if (mx >= x1 && mx <= x2 && my >= y1 && my <= y2) {
        // go into children to find if any sub table line is hit
        tree child_res= concrete_composite_box_rep::message (t, x, y, rs);
        if (child_res != "") return child_res;

        tree res (TUPLE);
        res << tree ("table-loc") << tree ("cell");
        return res;
    }
```

检测是否有子盒子被命中，如有则会递归到自己：
```cpp
tree
composite_box_rep::message (tree t, SI x, SI y, rectangles& rs) {
  int m= find_child (x, y, 0, true);
  if (m == -1) return "";
  else {
    rectangles xtra;
    tree       r= bs[m]->message (t, x - sx (m), y - sy (m), xtra);
    rs << translate (xtra, sx (m), sy (m));
    return r;
  }
}
```


## 2026/1/19
### What
Feat：表格内部格线支持鼠标拖动

### How
实现要点：
1. 事件入口 `edit_mouse.cpp`
	- 持续监听 `table-loc?`，在 hover 时区分行格线/列格线/单元格内，切换光标形态
	- 鼠标按下命中格线后进入拖动态
	  - `table_resize_hit` 解析 table-loc 元组
	  - `table_resize_start` 记录初始尺寸与索引
	  - `table_resize_apply` 基于鼠标位移计算新宽高并做最小尺寸约束
	  - `table_resize_stop` 收尾
2. 表格命中检测 `composite_boxes.cpp`
	- `table_box_rep::message` 覆盖消息通道，响应 "table-loc?"：
	  - 行格线命中返回 `("table-loc" "row" row_index border th bh cols rows ip)`
	  - 列格线命中返回 `("table-loc" "col" col_index border lw rw cols rows ip)`
	  - 单元格内命中返回 `("table-loc" "cell")`
3. 尺寸写回 `edit_table.cpp`
	- 新增 public 的 `table_set_format_region`（实际上直接调 `table_set_format` 传数据，只不过 `table_set_format` 在类中是 protected）
	- 通过 `table_resize_notify` 通知界面刷新，保证拖动过程的尺寸反馈实时可见
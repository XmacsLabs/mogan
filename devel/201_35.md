# [201_35] align环境编号后 smart-ref 以及 reference 失效

## 如何测试
打开 `TeXmacs\tests\tmu\201_35.tmu` ，查看 smart-ref 和 reference 的公式编号是否正确

- line1 的 label 编号应该都是1
- line2 的 label 编号应该都是2
- line3 的 label 编号应该都是3


## 2025/11/30
### What
在 align 环境中，若 `<label|id>` 出现在 `<eq-number>` 之前，则 `<reference|id>` 或 `<smart-ref|id>` 会"错位"，即显示上一行的编号或“?”。

### Why
这是一个执行时序问题，排版器按从左到右的顺序处理公式/表格时：
- `<label|id>` 实际展开是 `<set-binding|id|<value|the-label>>`（二参形式），然后立即用当前`the-label` 值绑定
- `<eq-number>` 内部调用 `<next-equation>`，然后执行 `<set-binding|<the-equation>>`（一参形式），更新计数器并设置 `the-label`

当 `<label|id>` 出现在 `<eq-number>` 之前时，在执行 `<set-binding|id|<value|the-label>>` 时 `the-label` 尚未更新，所以就绑定了错误的值

### How
1. 在`edit_env_rep::exec_set_binding` 中，当处理到 `<label|id>` 的二参形式的 `set-binding` 时，若值来自 `<value|the-label>`，则**将这个键加入 `the-tags`**。这样当后续处理到 `<eq-number>` 的一参形式的 `set-binding` 时，`the-tags` 能读取**这些键**，就会用正确的编号值去覆盖绑定它们。如下：
```cpp
if (is_func (t[1], VALUE, 1) && t[1][0] == THE_LABEL) {
  tree old_tags= read ("the-tags");
  if (is_tuple (old_tags)) {
    tree new_tags= old_tags * tuple (key);
    assign (string ("the-tags"), new_tags);
  }
}
```

2. 在 `table_rep::typeset_row` 中，在每行开始时隔离 `the-tags`，这样确保行与行之间的 `the-tags` 互不干扰，避免 `<label|id>` 如果打在 `<eq-number>` 之后，会被下一行的 `<eq-number>` 错误覆盖。如下：
```cpp
tree old_tags= env->local_begin ("the-tags", tree (TUPLE));
// ...
env->local_end ("the-tags", old_tags);
```

### FIX
1. 以上修改实测会触发覆盖绑定的警告。故在处理一参和二参形式时，当涉及延迟绑定时都设置 `refined= true` ，在后面需要流入 redefined 时检测 refined 并跳过即可

2. 在列表等环境下，如果新值并不符合可读要求（不是atomic结构）则跳过覆盖绑定
```cpp
// if refined but new value is not atomic, skip (only for 1-arg set-binding)
if (N (t) == 1 && !is_atomic (value) && is_func (old_value, TUPLE) && N (old_value) >= 1 && is_atomic (old_value[0])) continue;
```
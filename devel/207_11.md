# 207_11 优化大文档读写卡顿问题

## 2025/9/24
### 如何测试
打开一个超大.tm文档（~几十MiB），在标题末尾或段落块末尾按回车键新增一行，再按退格键删除这一行，观察删除操作用时是否和新增操作接近（200~500ms，不可超过1s）

### What
在读写大文档时，排版与渲染引擎负载非常大，通常在200ms左右。注意到在某些段落块结尾新增一行并删除时，卡顿时间可长达5s，存在严重的性能问题。

### Why

删除空行时，remove_return()合并CONCAT，桥接收到notify_join()

此后到notify_remove()会重建brs数组，pos两侧会notify_change并计算change_flag。如果被删除的那一段对应的brs[i]->changes非空，则将pos~n-1的所有brs[i]全部notify_change，也就是从join点到文档末尾的所有段都打上“需要重排”的标记。

这一步是主要的“放大器”：一旦change_flag为真，后继大量段被标记CORRUPTED，再进入my_typeset时（acc通常为空），就会对brs[i]一段段调用typeset(PROCESSED + WANTED)，形成巨量的typeset调用（实测在50MiB的tm文档中超过3万次）而导致~5s的卡顿。

在`bridge_document.cpp`中的重点代码：

```cpp
    if (change_flag) // touch brs[pos..n] for correct ``changes handling''
      for (i= pos; i < n; i++)
        brs[i]->notify_change ();
```

### How

采用如下策略：
- 如果删除的行数nr==1，仅触发pos-1与pos的邻域触摸；
- 如果nr>1，从pos起触发一个“近似页面大小”的窗口，避免全量级联。

```cpp
    if (nr > 1) {
      int start= pos;
      int end  = min (n, pos + PAGE_TOUCH_WINDOW);
      // PAGE_TOUCH_WINDOW is close to the ACC_THRESHOLD from accelerator
      // usually covers a page or few pages of flow
      for (i= start; i < end; i++)
        brs[i]->notify_change ();
    }
```

并开启文档范围加速器，避免不必要的全篇重排：

```cpp
void
bridge_document_rep::initialize_acc () {
  // Enable document-range acceleration in interactive (screen) mode
  // to minimize unnecessary full-document retypesetting.
  if (ttt->paper) acc= bridge ();
  else acc= bridge_docrange (ttt, st, ip, brs, 0, N (st), true);
}
```

**为什么这样不会漏更：**

- 脏区由加速器统一管理：
notify_remove会把受影响区间记为脏，不依赖是否逐段notify_change()

- 脏区在下一轮typeset被完整覆盖：
my_typeset会遍历[begin..end)调用每个子桥的typeset，因此落在脏区内的段都会重排，即使没有显式notify_change()

- 缓存只在“无旧补丁”时才生效：
子桥的typeset只有在(status==desired_status)&&N(ttt->old_patch)==0才走缓存分支；一旦脏区前部有变更，ttt->old_patch 非空，会强制后续段落走重排路径，确保连锁一致性（编号、引用、分页、浮动等都会更新）

- 邻域触摸只是加速即时反馈
只对pos-1/pos（或pos..pos+窗口）做notify_change()只是减少当帧不必要重排

**真正的全局一致由脏区重排保障，不会因为没触达更远段而永久不更新，最多是下一轮排版或滚动到可见时收敛**
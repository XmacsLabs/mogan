# [201_24] 正文与导言区切换时光标位置的保存

### 如何测试

在正文编辑时，切换到导言区编辑（win下快捷键'ctrl+shift+p'或菜单栏'源码'->'编辑导言区'）
编辑完导言区后切回正文编辑，检查光标位置是否与切换前一致


## 2025/10/5

### What
Ctrl+Shift+P切换导言区，切换回来之后，光标会在文档起始位置

### Why
当从导言区模式切回 :all（正常文本）分支时，之前的做法会丢失光标位置，且并没有做位置的记录：

```scheme
(tree-go-to (car (buffer-body-paragraphs)) :start)
```

因此需要在切入导言区时保存原光标路径，回退时就可以恢复

### How
为保持对称性，我同时增加了正文和导言区两部分的光标位置记录：
```scheme
(define body-restore-path #f)
(define preamble-restore-path #f)
```

在切换时保存当前光标路径：
```scheme
(when (and (== mode :preamble) (!= old-mode :preamble))
	(set! body-restore-path (cursor-path)))
(when (and (!= mode :preamble) (== old-mode :preamble))
	(set! preamble-restore-path (cursor-path)))
```

在切回时，若路径存在则： `go-to-path p`，若不存在则仍然有：`(tree-go-to (car (buffer-body-paragraphs)) :start)` 兜底

并使用`delayed (:idle 1)`在树被重写后再定位，避免定位过早

关键的恢复光标位置代码：
```scheme
((== mode :preamble)
	(when (tree-is? (tree-ref (buffer-tree) 0) 'hide-preamble)
		(buffer-show-preamble))
	(with p preamble-restore-path
		(set! preamble-restore-path #f)
		(if p
				(delayed (:idle 1)
					(catch #t
						(lambda () (go-to-path p))
						(lambda err (tree-go-to (buffer-tree) 0 0 :start))))
				(tree-go-to (buffer-tree) 0 0 :start))))
((== mode :all)
	(buffer-hide-preamble)
	(buffer-flatten-parts)
	(with p body-restore-path
		(set! body-restore-path #f)
		(if p
				(delayed (:idle 1)
					(catch #t
						(lambda () (go-to-path p))
						(lambda err (tree-go-to (car (buffer-body-paragraphs)) :start))))
				(tree-go-to (car (buffer-body-paragraphs)) :start)))
	(update-current-buffer))
```
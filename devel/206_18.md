# 第一阶段完成情况：代码分析

  1. 核心数据结构确认

  - 关键文件：src/Graphics/Fonts/font.hpp:57 确认了 font_rep 结构体中的 SI size; 字段
  - 当前类型：SI 是 int 类型（有符号整数），定义在 3rdparty/lolly/Kernel/Abstractions/minmax.hpp

  2. 需要修改的关键函数签名分析

  通过 grep 命令发现以下关键模式：

  int sz 参数使用情况：
  src/Graphics/Fonts/font.hpp:font virtual_font (font base, string fam, int sz, int hdpi, int vdpi, bool ext);
  src/Graphics/Fonts/font.hpp:font find_font (string family, string variant, string series, string shape, int sz, int dpi);
  src/Graphics/Fonts/font.hpp:font smart_font (string family, string variant, string series, string shape, int sz, int dpi);
  src/Graphics/Fonts/smart_font.hpp:font smart_font_bis (string f, string v, string s, string sh, int sz, int hdpi, int vdpi);
  src/Graphics/Fonts/font.cpp:int script (int sz, int level);

  get_int(FONT_BASE_SIZE) 使用情况（需要改为 get_double）：
  src/Typeset/Env/env_semantics.cpp:fn_size= (int) (((double) get_int (FONT_BASE_SIZE)) * get_double (FONT_SIZE) + 0.5);
  src/Typeset/Env/env_length.cpp: (get_int (FONT_BASE_SIZE) * magn * inch * get_double (FONT_SIZE)) / 72.0;
  （共找到7处使用）

  fn->size 使用情况（需要添加类型转换）：
  src/Typeset/Boxes/Composite/script_boxes.cpp:SI top= max (lo->y2, fn->y2 * script (fn->size, 1) / fn->size) + sep_lo;
  src/Typeset/Boxes/Modifier/modifier_boxes.cpp:SI syx= big_fn->yx * script (big_fn->size, 1) / big_fn->size;
  （共找到8处使用）

  3. 代码库结构理解

  - 字体系统核心目录：src/Graphics/Fonts/
  - 插件目录：src/Plugins/Freetype/、src/Plugins/Qt/、src/Plugins/Metafont/
  - 排版系统目录：src/Typeset/
  - Scheme UI 文件：TeXmacs/progs/fonts/font-new-widgets.scm

# 第二阶段完成情况：核心数据结构修改

  已完成的修改：

  1. 修改了 font_rep 结构体（双字段兼容设计）

  - 文件: src/Graphics/Fonts/font.hpp:57
  - 修改前: SI size; // requested size
  - 修改后: 采用双字段设计：
  SI     size_int;     // 整数字体尺寸（向后兼容）
  SI     design_size;  // design size in points/256
  SI     display_size; // display size in points/PIXEL
  double size_float;   // 浮点字体尺寸（新功能，默认0.0表示未使用）

  2. 添加了 effective_size() 成员函数

  - 功能: 获取有效字体尺寸，优先使用浮点尺寸，包含0.5倍数验证
  - 位置: font_rep 结构体内
  - 逻辑:
    - 如果 size_float > 0.0，验证是否为0.5倍数，如果不是则自动修正
    - 否则返回 (double)size_int

  3. 添加了辅助函数和兼容性处理

  - 文件: src/Graphics/Fonts/font.hpp（在 font_name_unpack 函数后添加）
  - 添加的函数:
  inline bool is_half_multiple(double sz);          // 验证是否为0.5倍数
  inline double round_to_half_multiple(double sz);  // 四舍五入到最近的0.5倍数
  inline double get_font_size(const font_rep* rep); // 获取实际尺寸（使用effective_size）
  inline void set_font_size(font_rep* rep, double size); // 设置尺寸（自动验证0.5倍数）
  inline int font_size_as_int(double sz);           // 兼容性包装函数（四舍五入）

  - 编译报错（已修复）：is_half_multiple() 和 round_to_half_multiple() 函数定义位置问题（移至 font_rep 结构体之前）

  4. 修改了构造函数初始化列表

  - 文件: src/Graphics/Fonts/font.cpp
  - **修改了 font_rep 的两个构造函数，更新字段初始化顺序

  5. 添加了必要的头文件

  - 在 font.hpp 中添加了 #include <cmath> 以支持 fabs 和 round 函数

# 第三阶段完成情况：函数签名更新

已完成的修改：

1. 更新字体创建函数声明

- 文件: src/Graphics/Fonts/font.hpp（多行需要修改）
- 修改的函数签名：
  - virtual_font：从 int sz 改为 double sz
  - find_font：从 int sz 改为 double sz
  - closest_font：从 int sz 改为 double sz
  - smart_font：从 int sz 改为 double sz
  - math_smart_font：从 int sz 改为 double sz
  - prog_smart_font：从 int sz 改为 double sz
  - x_font、qt_font、tex_font、tex_cm_font、tex_ec_font、tex_la_font、tex_gr_font、tex_adobe_font、tex_rubber_font：从 int sz 改为 double sz

2. 更新 smart_font_bis 函数

- 文件: src/Graphics/Fonts/smart_font.hpp:34-35
- 修改前: font smart_font_bis (string f, string v, string s, string sh, int sz, int hdpi, int vdpi);
- 修改后: font smart_font_bis (string f, string v, string s, string sh, double sz, int hdpi, int vdpi);

3. 更新 unicode_font 函数

- 文件: src/Graphics/Fonts/font.hpp:376-386
- 修改前: font unicode_font (string family, int size, int dpi);
- 修改后: font unicode_font (string family, double size, int dpi);

4. 更新 script() 函数声明

- 文件: src/Graphics/Fonts/font.hpp:263
- 修改前: int script (int sz, int level);
- 修改后: double script (double sz, int level);

5. 更新 get_script_size() 函数声明

- 文件: src/Typeset/env.hpp:521
- 修改前: int get_script_size (int sz, int level);
- 修改后: double get_script_size (double sz, int level);

# 第四阶段完成情况：实现文件修改

已完成的修改：

1. 修改 smart_font.cpp 中的实现

- 文件: src/Graphics/Fonts/smart_font.cpp:1725-1781
- smart_font_bis() 函数：
  - 参数从 int sz 改为 double sz
  - 添加0.5倍数验证和自动修正逻辑
  - 浮点尺寸字符串处理：整数如"10"，0.5倍数如"10.5"
  - 缓存键生成正确处理浮点数

- smart_font() 函数：
  - 参数从 int sz 改为 double sz
  - 添加0.5倍数验证和自动修正逻辑

2. 修改 virtual_font.cpp

- 文件: src/Graphics/Fonts/virtual_font.cpp:44-45, 2056-2065
- virtual_font_rep 构造函数：
  - 参数从 int size 改为 double size
- virtual_font() 函数：
  - 参数从 int size 改为 double size
  - 添加0.5倍数验证和自动修正逻辑
  - 浮点尺寸字符串处理

# 第五阶段完成情况：计算函数适配

已完成的修改：

1. 修改 script() 函数（关键计算函数）

- 文件: src/Graphics/Fonts/font.cpp:577-592（用户已修改）
- 修改前: int script (int sz, int level) { ... } // 整数除法，精度丢失
- 修改后: double script (double sz, int level) { ... } // 浮点计算，保持精度
- 添加0.5倍数输入验证
- 浮点除法保持精度，输出可能不是0.5倍数（设计允许）

2. 修改 env_semantics.cpp 中的 get_script_size() 实现和字体缓存系统

- 文件: src/Typeset/Env/env_semantics.cpp
- 函数签名已改为 `double get_script_size(double sz, int level)`
- 关键修改：
  1. 添加0.5倍数验证：使用 `is_half_multiple()` 和 `round_to_half_multiple()` 确保输入为0.5倍数
  2. 修改索引计算：从 `(int)(sz + 0.5)` 改为 `(int)(sz * 2.0)`，正确支持0.5倍数索引
  3. 更新缓存访问：`array<int>& a (size_cache[isz])` 改为 `array<double>& a (size_cache[isz])`
  4. 添加头文件包含：`#include "Graphics/Fonts/font.hpp"` 以使用浮点辅助函数

3. 修改 determine_sizes() 函数以支持浮点字体尺寸

- 文件: src/Typeset/Env/env_semantics.cpp:491
- 函数签名修改：从 `determine_sizes (tree szt, int sz)` 改为 `determine_sizes (tree szt, double sz)`
- 返回类型修改：从 `array<int>` 改为 `array<double>`
- 内部修改：
  1. `r << as_int (s)` 改为 `r << (double) as_int (s)`
  2. `int xsz= (int) ceil ((x - 0.001) * sz)` 改为 `double xsz= ceil ((x - 0.001) * sz)`
  3. `r << script (sz, 1)` 和 `r << script (sz, 2)` 保持不变（script() 已返回 double）
  4. 更新调用处：`size_cache << determine_sizes (math_font_sizes, xsz)` 中的 xsz 从 int 改为 double

# 第六阶段完成情况：环境处理修改

已完成的修改：

1. 修改字体大小计算逻辑

- 文件: src/Typeset/Env/env_semantics.cpp:540-541
- 修改前: fn_size= (int) (((double) get_int (FONT_BASE_SIZE)) * get_double (FONT_SIZE) + 0.5);
- 修改后:
  double base_size = get_double (FONT_BASE_SIZE);
  fn_size = base_size * get_double (FONT_SIZE);
- fn_size 类型已改为 double（在 env.hpp 中定义）

2. 更新 env.hpp 中的 fn_size 类型

- 文件: src/Typeset/env.hpp:178
- 修改前: int fn_size;
- 修改后: double fn_size;

3. 更新 env.hpp 中的 size_cache 类型以支持浮点字体尺寸

- 文件: src/Typeset/env.hpp:161
- 修改前: `array<array<int>> size_cache;  // math font size cache`
- 修改后: `array<array<double>> size_cache;  // math font size cache`
- 原因：字体缓存系统需要支持0.5倍数字体尺寸，因此需要将整数缓存改为浮点缓存

4. 更新 env_semantics.cpp 中的 size_cache 初始化代码

- 文件: src/Typeset/Env/env_semantics.cpp:919 和 1007
- 修改前: `size_cache = array<array<int>> ();`
- 修改后: `size_cache = array<array<double>> ();`
- 影响：两处初始化代码都需要更新类型以匹配新的浮点缓存类型

5. 更新其他使用 get_int(FONT_BASE_SIZE) 的地方

- 文件: src/Typeset/Env/env_length.cpp（多处修改）
- 修改的函数：
  - exec_fs_length(): get_int → get_double
  - exec_fbs_length(): get_int → get_double
  - exec_fn_length(): get_int → get_double
  - exec_fns_length(): get_int → get_double
  - exec_bls_length(): get_int → get_double
- 所有相关计算现在使用浮点精度

# 第七阶段完成情况：布局计算适配

已完成的修改：

1. 修改 script_boxes.cpp 中的计算

- 文件: src/Typeset/Boxes/Composite/script_boxes.cpp（4处修改）
- 修改的表达式：
  - line 94: SI top = max (lo->y2, fn->y2 * script (fn->size, 1) / fn->size) + sep_lo;
    → SI top = max (lo->y2, (SI)(fn->y2 * script (fn->effective_size (), 1) / fn->effective_size () + 0.5)) + sep_lo;
  - line 106: SI bot = min (hi->y1, fn->y1 * script (fn->size, 1) / fn->size) - sep_hi;
    → SI bot = min (hi->y1, (SI)(fn->y1 * script (fn->effective_size (), 1) / fn->effective_size () + 0.5)) - sep_hi;
  - line 210: SI miny2 = (fn->y2 - fn->yshift) * script (fn->size, 1) / fn->size;
    → SI miny2 = (SI)((fn->y2 - fn->yshift) * script (fn->effective_size (), 1) / fn->effective_size () + 0.5);
  - line 374: SI miny2 = (fn->y2 - fn->yshift) * script (fn->size, 1) / fn->size;
    → SI miny2 = (SI)((fn->y2 - fn->yshift) * script (fn->effective_size (), 1) / fn->effective_size () + 0.5);

2. 修改 modifier_boxes.cpp

- 文件: src/Typeset/Boxes/Modifier/modifier_boxes.cpp:449
- 修改前: SI syx = big_fn->yx * script (big_fn->size, 1) / big_fn->size;
- 修改后: SI syx = (SI)(big_fn->yx * script (big_fn->effective_size (), 1) / big_fn->effective_size () + 0.5);

3. 更新相关文件中的类型

- 文件: src/Typeset/Concat/concater.cpp（3处）
  - line 49: int sz → double sz
  - line 96: int sz → double sz
  - line 129: int sz → double sz
- 文件: src/Typeset/Concat/concat_animate.cpp:231
  - line 231: int sz → double sz

4. 修改 smart_font.cpp 中的字体效果计算

- 文件: src/Graphics/Fonts/smart_font.cpp（2处修改）
  - line 1962: if (rad_unit == "pt") rad_val= rad_val / fn->size;
    → if (rad_unit == "pt") rad_val= rad_val / fn->effective_size ();
  - line 1974: if (rad_unit == "pt") rad_val= rad_val / fn->size;
    → if (rad_unit == "pt") rad_val= rad_val / fn->effective_size ();
- 修改原因：字体效果（模糊、增强）计算需要基于实际字体尺寸

# 第八阶段完成情况：插件适配

已完成的修改：

1. 修改 Qt 插件

- 文件: src/Plugins/Qt/qt_gui.cpp:1035
  - load_system_font() 参数从 int sz 改为 double sz
- 文件: src/Plugins/Qt/qt_font.hpp
  - qt_font_rep 构造函数从 int size 改为 double size
  - size 字段从 int 改为 double
- 文件: src/Plugins/Qt/qt_font.cpp:29-43
  - qt_font_rep 构造函数添加0.5倍数验证
  - 修正 design_size 计算：从 size << 8 改为 (SI)(size * 256.0)
  - 如果尺寸被修正，重新初始化 QFont 和 QFontMetricsF

2. 修改 Freetype 插件

- 文件: src/Plugins/Freetype/unicode_font.hpp:44
  - unicode_font_rep 构造函数从 int size 改为 double size
- 文件: src/Plugins/Freetype/unicode_font.cpp
  - unicode_font() 函数（两个重载）从 int size 改为 double size
  - 添加0.5倍数验证和浮点尺寸字符串处理
  - unicode_font_rep 构造函数添加0.5倍数验证
  - 注意：size 字段可能仍是 int，但 font_rep 有 size_int 和 size_float 字段

3. 修改 font.hpp 中的 tt_font() 函数

- 文件: src/Graphics/Fonts/font.hpp:427-432
- 参数从 int size 改为 double size
- 添加0.5倍数验证和浮点尺寸字符串处理

# 第九阶段完成情况：用户界面适配

已完成的修改：

1. 扩展字体大小预设列表

- 文件: TeXmacs/progs/fonts/font-new-widgets.scm:476-483
- 修改 font-default-sizes 列表：
  - 添加 8.5、9.5、10.5、11.5、12.5、13、15 等0.5倍数尺寸
  - 保持向后兼容性，保留原有整数尺寸
- 修改 font-default-sizes* 列表：
  - 添加 8.5、9.5、10.5、11.5 等常用0.5倍数尺寸

# 第十阶段完成情况：测试验证（待完成）

待测试项目：

1. 单元测试
   - 需要创建或修改现有测试文件
   - 测试0.5倍数验证函数：is_half_multiple()、round_to_half_multiple()
   - 测试浮点字体创建：smart_font()、virtual_font() 等
   - 测试script()函数计算结果
   - 测试缓存键生成

2. 视觉回归测试
   - 创建测试文档：10pt、10.5pt、11pt 字体对比
   - 检查布局正确性：包含浮点字体的文档
   - 验证导出功能：PDF/HTML 导出保持正确字体尺寸
   - 兼容性测试：现有整数字体大小文档正常显示

# 第十一阶段完成情况：编译和调试

当前状态：

1. 编译检查
   - 已完成所有核心修改
   - 需要验证编译无错误
   - 注意类型转换和头文件包含问题

3. 编译错误修复

已修复的编译错误：

### 错误1: virtual_enhance.cpp:53 - "size": 不是 "font_rep" 的成员
**文件**: src/Graphics/Fonts/virtual_enhance.cpp
**错误**: `base->size` 访问不存在的成员
**修复**: `base->size` → `base->effective_size()`
**原因**: `font_rep` 结构体已改为双字段设计（`size_int` + `size_float`），应使用 `effective_size()` 获取实际尺寸。

### 错误2: smart_font.cpp:614 - 构造函数签名不匹配
**文件**: src/Graphics/Fonts/smart_font.cpp
**错误**: `smart_font_rep::smart_font_rep(string, font, font, string, string, string, string, int, int, int)` 找不到重载成员函数
**修复**: 构造函数参数从 `int sz2` 改为 `double sz2`
**原因**: 头文件声明已更新为 `double sz`，但实现文件中的定义仍是 `int sz2`。

### 错误3: unicode_font.cpp:138-145 - 访问不存在的 size 成员
**文件**: src/Plugins/Freetype/unicode_font.cpp
**错误**:
1. `size = size2;` - 访问不存在的成员
2. `tt_font_metric(family, size, ...)` - 使用不存在的成员
3. `tt_font_glyphs(family, size, ...)` - 使用不存在的成员
4. 调试输出中的 `size` - 使用不存在的成员
**修复**:
1. `size = size2;` → `set_font_size(this, size2);`
2. `tt_font_metric(family, size, ...)` → `tt_font_metric(family, size2, ...)`
3. `tt_font_glyphs(family, size, ...)` → `tt_font_glyphs(family, size2, ...)`
4. 调试输出中的 `size` → `size2`
**原因**: `unicode_font_rep` 没有 `size` 成员，应使用 `set_font_size()` 辅助函数。

### 错误4: 其他 ->size 使用位置
**问题**: 多个文件中调用 `virtual_font()` 或 `unicode_font()` 时传递 `base->size`
**修复**: 所有 `base->size` 改为 `base->effective_size()`
**影响文件**:
- `src/Graphics/Fonts/poor_rubber.cpp`: 第94行、第104行
- `src/Plugins/Freetype/rubber_unicode_font.cpp`: 第144行
- `src/Plugins/Freetype/rubber_stix_font.cpp`: 第85-123行（共23处）
- `src/Plugins/Freetype/rubber_assemble_font.cpp`: 第57行

### 错误5: env_semantics.cpp:517-518 - 类型不匹配和字体缓存系统编译错误
**文件**: src/Typeset/Env/env_semantics.cpp
**错误**:
1. `error C2678: 二进制"<<"：没有找到接受"array<int>"类型的左操作数的运算符`
2. `determine_sizes()` 函数处理整数尺寸，不支持浮点字体尺寸
3. `get_script_size()` 函数将浮点尺寸四舍五入为整数，导致0.5倍数处理错误（如10.5pt被当作11pt）
4. `size_cache` 类型不匹配，仍使用 `array<array<int>>` 而不是 `array<array<double>>`

**修复**:
1. **修改 `determine_sizes()` 函数签名**：
   - 从 `determine_sizes (tree szt, int sz)` 改为 `determine_sizes (tree szt, double sz)`
   - 返回类型从 `array<int>` 改为 `array<double>`
   - 内部类型转换：`r << (double) as_int (s)` 和 `double xsz= ceil ((x - 0.001) * sz)`

2. **修改 `get_script_size()` 函数实现**：
   - 添加0.5倍数验证：`is_half_multiple()` 和 `round_to_half_multiple()`
   - 修改索引计算：从 `(int)(sz + 0.5)` 改为 `(int)(sz * 2.0)`，正确支持0.5倍数索引
   - 更新缓存访问：`array<int>& a (size_cache[isz])` 改为 `array<double>& a (size_cache[isz])`

3. **更新 `size_cache` 类型定义**：
   - 文件 `src/Typeset/env.hpp:161`: `array<array<int>> size_cache;` → `array<array<double>> size_cache;`
   - 文件 `src/Typeset/Env/env_semantics.cpp:919,1007`: `size_cache = array<array<int>> ();` → `size_cache = array<array<double>> ();`

4. **添加头文件包含**：
   - 在 `env_semantics.cpp` 中添加 `#include "Graphics/Fonts/font.hpp"` 以使用浮点辅助函数

**原因**: 字体缓存系统需要完整支持0.5倍数字体尺寸，原整数缓存系统无法正确处理浮点尺寸，导致编译错误和功能错误（如10.5pt被错误地当作11pt处理）。

### 关键修改点总结
1. **双字段架构**: `font_rep` 现在使用 `size_int`（兼容）和 `size_float`（新功能）
2. **0.5倍数限制**: 所有浮点字体尺寸必须是0.5的倍数，输入会自动修正
3. **`effective_size()`**: 优先使用 `size_float`，否则使用 `(double)size_int`
4. **`set_font_size()`**: 设置尺寸时自动验证0.5倍数并更新双字段
5. **字体缓存系统浮点支持**: `size_cache` 从 `array<array<int>>` 改为 `array<array<double>>`，支持0.5倍数字体尺寸缓存

4. 已知问题
   - [已修复] 插件函数 tt_font_metric() 和 tt_font_glyphs() 已更新为支持 double 参数
   - [已修复] 所有浮点到SI的转换已添加 +0.5 四舍五入（script_boxes.cpp、modifier_boxes.cpp等）
   - [已修复] 缓存系统已更新为支持浮点尺寸键：`size_cache` 类型从 `array<array<int>>` 改为 `array<array<double>>`
   - [新问题] 编译后需要运行测试验证功能正确性
   - [新问题] 需要验证0.5倍数字体在UI中正确显示

# 总结

已完成工作：
- 双字段架构实现：size_int + size_float
- 0.5倍数限制：所有输入验证和自动修正
- 函数签名更新：所有相关函数从 int sz 改为 double sz
- 计算适配：script() 函数和布局计算
- 布局计算使用 effective_size() 而不是直接访问 size 字段
- 插件更新：Qt 和 Freetype 插件
- UI适配：字体预设列表扩展
- 类型安全：所有浮点到SI转换添加 +0.5 四舍五入
- 字体缓存系统浮点支持：`size_cache` 类型更新为 `array<array<double>>`，支持0.5倍数字体尺寸

待完成工作：
- 编译测试和错误修复（已完成）
  - 已修复：virtual_enhance.cpp 中 base->size 访问问题（改为 base->effective_size()）
  - 已修复：smart_font.cpp 构造函数签名不匹配问题（int sz2 → double sz2）
  - 已修复：unicode_font.cpp 中 size 成员访问问题（使用 set_font_size() 辅助函数）
  - 已修复：多个文件中的 ->size 使用问题（改为 ->effective_size()）
  - 已修复：env_semantics.cpp 中的字体缓存系统类型错误（array<array<int>> → array<array<double>>）
- 单元测试和视觉回归测试
- 性能监控和优化验证
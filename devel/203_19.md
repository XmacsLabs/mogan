# [203_19] 修复 \overset \stackrel \underset 解析问题

### 如何测试
以LaTeX形式导入一下公式，应该都能正确显示
1. `\( 2{\mathrm{{NaHCO}}}_{3}\overset{\bigtriangleup }{ = }{\mathrm{{Na}}}_{2}{\mathrm{{CO}}}_{3} + {\mathrm{H}}_{2}\mathrm{O} + {\mathrm{{CO}}}_{2} \uparrow \)`，完整overset，正三角在等号上面
2. `\( \overset{\bigtriangleup }{ = } \)`，部分overset，正三角在等号上面
3. `\( \stackrel{\bigtriangleup }{ = } \)`，部分stackrel，正三角在等号上面
4. `\( \underset{\bigtriangleup }{ = } \)`，部分downset，正三角在等号下面

集成测试文件在 `TeXmacs/tests/203_19.scm`

## 2026/1/15
### What
导入 latex 时，`\overset` 解析有问题

### Why
公式中在 `overset{}{}` 后如果还有一个 `{}`，overset 会认为是三参形式渲染，但实际上 overset 的if分支只接受二参形式，故无法解析

同时 stackrel underset 也存在类似问题

### How
在 `fromtex.cpp` 中写一个lambda `handle_over_under` 用于处理这三个上下标命令的结构树：
```cpp
auto handle_over_under= [&] (const string& cmd, bool below) {
    if (!is_tuple (t) || N (t) < 3 || as_string (t[0]) != cmd) return false;
    tree cur_tree= tree (below ? BELOW : ABOVE, l2e (t[2]), l2e (t[1]));
    if (N (t) == 3) out_tree= cur_tree;
    else {
      tree tmp (CONCAT);
      tmp << cur_tree;
      for (int i= 3; i < N (t); i++)
        tmp << l2e (t[i]);
      out_tree= tmp;
    }
    return true;
  };
```

之后对这三者都用这个处理即可，方式相同：
```cpp
if (handle_over_under ("\\stackrel", false)) return out_tree;
if (handle_over_under ("\\overset", false)) return out_tree;
if (handle_over_under ("\\underset", true)) return out_tree;
```
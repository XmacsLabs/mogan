# 200_44
## 如何测试
1. **正常退出测试：**
   - 启动 Mogan，运行一个插件（如 Python 插件）
   - 正常关闭窗口，检查子进程是否被清理

2. **Ctrl+C 测试：**
   - 启动 Mogan，运行插件
   - 在终端按 Ctrl+C，检查子进程是否被清理

3. **崩溃信号测试：**
   - 在代码中手动触发崩溃（如 `raise(SIGSEGV)`）
   - 检查子进程是否被清理

4. **调试日志验证：**
   - 运行时查看 `[KILL]` 日志输出
   - 确认进程终止命令被执行

```bash
# 检查残留进程
ps aux | grep -i python
# 或
pgrep -af mogan
```


## 2026/1/16 完善插件进程清理机制

### What
1. **添加统一的信号处理器** (`src/System/Boot/init_texmacs.cpp`)
   - 新增 `clean_exit_on_signal()` 函数，处理崩溃和强制终止信号
   - 注册信号处理器：SIGSEGV, SIGTRAP, SIGABRT, SIGTERM, SIGQUIT
   - 每种信号发生时先调用 `close_all_pipes()` 清理子进程，再打印堆栈跟踪（针对崩溃类信号）
   - 添加 `tm_link.hpp` 头文件引用

2. **在析构函数中添加子进程清理** (`src/Texmacs/Server/tm_server.cpp`)
   - 在 `~tm_server_rep()` 中添加 `close_all_pipes()` 调用
   - 确保正常退出和 Ctrl+C (SIGINT) 导致 Qt 事件循环退出后也能清理子进程

3. **优化进程终止机制** (`src/Plugins/Qt/QTMPipeLink.cpp`)
   - 简化 `killProcess()` 函数，直接使用 `kill()` 终止进程
   - 添加重试机制：最多 4 次，每次等待 50ms（总耗时约 200ms）
   - 每次终止操作打印调试日志，显示进程命令和重试次数

### Why
**问题背景：**
- 当 Mogan 软件异常退出（如崩溃、被 kill 命令终止）时，插件子进程不会被清理
- 残留的子进程会变成孤儿进程，继续占用系统资源
- 用户报告遇到 "killed by signal trace/BPT trap" 等情况时插件未被清理

**技术分析：**
- 原有代码只注册了 SIGSEGV 信号处理器，且只打印堆栈不清理子进程
- 析构函数 `~tm_server_rep()` 为空，正常退出时不会主动清理子进程
- Qt 版本的 `killProcess()` 在 Unix 上使用 `terminate()` + `waitForFinished(0)`，实际上等同于直接 `kill()`
- Windows 上只调用 `close()`，不终止进程本身

**解决方案：**
- 通过信号处理器覆盖异常退出场景
- 通过析构函数覆盖正常退出和 Ctrl+C 场景
- 统一使用 `kill()` 确保进程被可靠终止

### How
### Notes
- 所有平台都使用 Qt 版本的 pipe 实现（`qt_pipe_link.cpp`）
- `close_all_pipes()` 是幂等的，多次调用安全
- `QProcess::kill()` 在 Unix 上发送 SIGKILL，在 Windows 上调用 TerminateProcess
- 总超时时间约 200ms，用户体验几乎无影响

### 覆盖的退出场景
| 退出方式 | 清理机制 |
|---------|---------|
| 段错误 (SIGSEGV) | 信号处理器 → `close_all_pipes()` |
| 断点陷阱 (SIGTRAP) | 信号处理器 → `close_all_pipes()` |
| Abort (SIGABRT) | 信号处理器 → `close_all_pipes()` |
| Kill 命令 (SIGTERM) | 信号处理器 → `close_all_pipes()` |
| Ctrl+\ (SIGQUIT) | 信号处理器 → `close_all_pipes()` |
| Ctrl+C (SIGINT) | 析构函数 → `close_all_pipes()` |
| 正常退出 | 析构函数 → `close_all_pipes()` |

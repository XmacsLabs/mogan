# 201_29

## 如何测试
在第十页插入Goldfish Scheme会话并运行：
```
(begin
  (import (texmacs protocol)
          (liii lang)
          (liii os))
  
  (define (print-formula n)
    (data-begin)
    (display "latex:")
    ((rich-list :range 1 (+ n 1))
     :for-each
     (lambda (i)
       (flush-latex (string-append "$x_{" (number->string i) "}$"))
       (flush-verbatim "\n")
       (flush-output-port)
       (os-call "sleep 1")))
    (data-end))
  
  (print-formula 100))
```

保持光标放在第一页，使用鼠标滚轮滚到第三页。在修复前，会自动滚回第一页。

## 2025/10/23 修复目录无法正常跳转的问题
### How
在 go-to 的 C++ 相关代码中手动添加 set_user_active 为 true 的代码，由于切换到某一节，最终实际调用的是 go-to，在 set_user_active 为 true 的情况下，就能保证自动跳转了。

另外，插件在不断输入内容的过程中，也会不断调用go-to，所以我们在 session-output 中添加了 set-user-active 为 #f 的代码，插件在完成内容输入的之后，最终会调用 tree-go-to 跳转到下一个输入的位置，这个时候为了不会重新定位，我们也需要 set-user-active。

## 2025/08/28 修复自动滚动到光标处的问题 by Zhiyu Zhou
### What
这个修复带来了另外一个问题，目录无法正常跳转。

### How
核心机制

1. 新增 user_active 状态 (src/Edit/editor.hpp:64)：
  - 添加了 bool user_active 字段来跟踪用户是否处于活动状态
2. 用户活动状态管理：
  - 键盘输入 (src/Edit/Interface/edit_keyboard.cpp:272)：key_press 方法中设置 set_user_active(true)
  - 鼠标输入 (src/Edit/Interface/edit_mouse.cpp:730)：handle_mouse 方法中，当不是移动事件或有选择时设置 set_user_active(true)
3. 自动滚动控制 (src/Edit/Interface/edit_interface.cpp:879-882)：
  - 只有当 get_user_active() 为 true 时，才会执行 cursor_visible() 自动滚动到光标位置
  - 执行后立即重置 set_user_active(false) 防止持续触发
4. 初始化 (src/Edit/Interface/edit_interface.cpp:72)：
  - 默认 user_active = false
5. 服务器端清理 (src/Texmacs/Server/tm_server.cpp:223)：
  - 在 interpose_handler 中定期重置所有视图的 user_active 状态

设计思路

这个修复的核心思想是区分用户主动操作和程序自动行为：
- 用户主动操作（键盘、鼠标点击等）：设置 user_active = true，允许自动滚动到光标
- 程序自动行为（插件持续输入等）：保持 user_active = false，禁止自动滚动

这样既保留了正常的用户交互体验，又解决了插件持续输入时的干扰问题。

副作用

这个修复带来了另一个问题：目录无法正常跳转。这是因为目录跳转也被识别为程序自动行为，没有触发 user_active 状态。
